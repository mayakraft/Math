!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).math=e()}(this,(function(){"use strict";const t=1e-6,e=180/Math.PI,r=Math.PI/180,n=2*Math.PI,o=Object.freeze({__proto__:null,EPSILON:t,R2D:e,D2R:r,TWO_PI:n}),a=(e,r,n=t)=>Math.abs(e-r)<n,i=(e,r,n=t)=>a(e,r,n)?0:Math.sign(r-e),c=(e,r,n=t)=>{for(let t=0;t<Math.max(e.length,r.length);t+=1)if(!a(e[t]||0,r[t]||0,n))return!1;return!0},s=(e,r=t)=>e>-r,l=(e,r=t)=>e>r,u=()=>!0,p=()=>!0,m=s,h=l,g=(e,r=t)=>e>-r&&e<1+r,d=(e,r=t)=>e>r&&e<1-r,f=t=>t,v=e=>e<-t?0:e>1.000001?1:e,M=Object.freeze({__proto__:null,epsilonEqual:a,epsilonCompare:i,epsilonEqualVectors:c,include:s,exclude:l,includeL:u,excludeL:p,includeR:m,excludeR:h,includeS:g,excludeS:d,clampLine:f,clampRay:e=>e<-t?0:e,clampSegment:v}),_=t=>null!=t&&"function"==typeof t[Symbol.iterator],x=function(){switch(arguments.length){case void 0:case 0:return Array.from(arguments);case 1:return _(arguments[0])&&"string"!=typeof arguments[0]?x(...arguments[0]):[arguments[0]];default:return Array.from(arguments).map((t=>_(t)?[...x(t)]:t))}},y=function(){switch(arguments.length){case void 0:case 0:return Array.from(arguments);case 1:return _(arguments[0])&&"string"!=typeof arguments[0]?y(...arguments[0]):[arguments[0]];default:return Array.from(arguments).map((t=>_(t)?[...y(t)]:t)).reduce(((t,e)=>t.concat(e)),[])}},b=Object.freeze({__proto__:null,semiFlattenArrays:x,flattenArrays:y}),k=function(){let t=y(arguments);const e=t[0];return"object"!=typeof e||null===e||Number.isNaN(e.x)||(t=["x","y","z"].map((t=>e[t])).filter((t=>void 0!==t))),t.filter((t=>"number"==typeof t))},P=function(){return x(arguments).map((t=>k(t)))},O=(t=[],e=[])=>({vector:t,origin:e}),z=Object.freeze({__proto__:null,getVector:k,getArrayOfVectors:P,getSegment:function(){const t=x(arguments);return 4===t.length?[[0,1],[2,3]].map((e=>e.map((e=>t[e])))):t.map((t=>k(t)))},getLine:function(){const t=x(arguments);return 0===t.length?O([],[]):t[0].constructor===Object&&void 0!==t[0].vector?O(t[0].vector||[],t[0].origin||[]):"number"==typeof t[0]?O(k(t)):O(...t.map((t=>k(t))))}}),j=(t,e)=>t+(e||0),A=t=>Math.sqrt(t.map((t=>t*t)).reduce(j,0)),C=t=>Math.sqrt(t[0]*t[0]+t[1]*t[1]),L=t=>Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]),w=t=>t.map((t=>t*t)).reduce(j,0),N=t=>{const e=A(t);return 0===e?t:t.map((t=>t/e))},S=t=>{const e=C(t);return 0===e?t:[t[0]/e,t[1]/e]},R=t=>{const e=L(t);return 0===e?t:[t[0]/e,t[1]/e,t[2]/e]},I=(t,e)=>t.map((t=>t*e)),q=(t,e)=>[t[0]*e,t[1]*e],F=(t,e)=>[t[0]*e,t[1]*e,t[2]*e],T=(t,e)=>t.map(((t,r)=>t+(e[r]||0))),E=(t,e)=>[t[0]+e[0],t[1]+e[1]],B=(t,e)=>[t[0]+e[0],t[1]+e[1],t[2]+e[2]],V=(t,e)=>t.map(((t,r)=>t-(e[r]||0))),D=(t,e)=>[t[0]-e[0],t[1]-e[1]],Z=(t,e)=>[t[0]-e[0],t[1]-e[1],t[2]-e[2]],U=(t,e)=>t.map(((r,n)=>t[n]*e[n])).reduce(j,0),$=(t,e)=>t[0]*e[0]+t[1]*e[1],X=(t,e)=>q(E(t,e),.5),Y=(t,e,r)=>{const n=1-r;return t.map(((t,o)=>t*n+(e[o]||0)*r))},H=(t,e)=>t[0]*e[1]-t[1]*e[0],Q=(t,e)=>[t[1]*e[2]-t[2]*e[1],t[2]*e[0]-t[0]*e[2],t[0]*e[1]-t[1]*e[0]],W=(t,e)=>Math.sqrt(t.map(((r,n)=>(t[n]-e[n])**2)).reduce(j,0)),G=(t,e)=>{const r=t[0]-e[0],n=t[1]-e[1];return Math.sqrt(r*r+n*n)},J=t=>t.map((t=>-t)),K=t=>[-t[1],t[0]],tt=t=>[t[1],-t[0]],et=(e,r,n=t)=>1-Math.abs(U(e,r))<n,rt=(e,r,n=t)=>et(N(e),N(r),n),nt=(t,e)=>e.length===t?e:Array(t).fill(0).map(((t,r)=>e[r]?e[r]:t)),ot=Object.freeze({__proto__:null,magnitude:A,magnitude2:C,magnitude3:L,magSquared:w,normalize:N,normalize2:S,normalize3:R,scale:I,scale2:q,scale3:F,add:T,add2:E,add3:B,subtract:V,subtract2:D,subtract3:Z,dot:U,dot2:$,dot3:(t,e)=>t[0]*e[0]+t[1]*e[1]+t[2]*e[2],midpoint:(t,e)=>t.map(((t,r)=>(t+e[r])/2)),midpoint2:X,midpoint3:(t,e)=>F(B(t,e),.5),average:function(){if(0===arguments.length)return[];const t=arguments[0].length>0?arguments[0].length:0,e=Array(t).fill(0);return Array.from(arguments).forEach((t=>e.forEach(((r,n)=>{e[n]+=t[n]||0})))),e.map((t=>t/arguments.length))},lerp:Y,cross2:H,cross3:Q,distance:W,distance2:G,distance3:(t,e)=>{const r=t[0]-e[0],n=t[1]-e[1],o=t[2]-e[2];return Math.sqrt(r*r+n*n+o*o)},flip:J,rotate90:K,rotate270:tt,degenerate:(e,r=t)=>e.map((t=>Math.abs(t))).reduce(j,0)<r,parallelNormalized:et,parallel:rt,parallel2:(e,r,n=t)=>Math.abs(H(e,r))<n,resize:nt,resizeUp:(t,e)=>[t,e].map((r=>nt(Math.max(t.length,e.length),r)))}),at=t=>Math.atan2(t[1],t[0]),it=t=>[Math.cos(t),Math.sin(t)],ct=Object.freeze({__proto__:null,vectorToAngle:at,angleToVector:it,pointsToLine:(...t)=>{const e=P(...t);return{vector:V(e[1],e[0]),origin:e[0]}},rayLineToUniqueLine:({vector:t,origin:e})=>{const r=A(t),n=K(t),o=U(e,n)/r;return{normal:I(n,1/r),distance:o}},uniqueLineToRayLine:({normal:t,distance:e})=>({vector:tt(t),origin:I(t,e)})}),st=function(t){const e=`${t}`.match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);return e?Math.max(0,(e[1]?e[1].length:0)-(e[2]?+e[2]:0)):0},lt=(t,e,r)=>{const n=t.map(((t,n)=>({i:n,d:r(e,t)})));let o,a=1/0;for(let t=0;t<n.length;t+=1)n[t].d<a&&(o=t,a=n[t].d);return o},ut=(e,r=t)=>{if(!e.length)return;const n=((e,r=0,n=i,o=t)=>{let a=[0];for(let t=1;t<e.length;t+=1)switch(n(e[t][r],e[a[0]][r],o)){case 0:a.push(t);break;case 1:a=[t]}return a})(e,0,i,r);let o=0;for(let t=1;t<n.length;t+=1)e[n[t]][1]<e[n[o]][1]&&(o=t);return n[o]},pt=(t,e,r)=>t.map(((t,n)=>({i:n,n:r(t,e)}))).sort(((t,e)=>t.n-e.n)).map((t=>t.i)),mt=(e,r=t)=>{const n=[[0]];let o=0;for(let t=1;t<e.length;t+=1)a(e[t],e[t-1],r)?n[o].push(t):(o=n.length,n.push([t]));return n},ht=(e=[],r=t)=>{const n=ut(e,r),o=e.map((t=>D(t,e[n]))).map((t=>S(t))).map((t=>$([0,1],t))),a=o.map(((t,e)=>({a:t,i:e}))).sort(((t,e)=>t.a-e.a)).map((t=>t.i)).filter((t=>t!==n));return[[n]].concat(mt(a.map((t=>o[t])),r).map((t=>t.map((t=>a[t])))).map((t=>1===t.length?t:t.map((t=>({i:t,len:G(e[t],e[n])}))).sort(((t,e)=>t.len-e.len)).map((t=>t.i)))))},gt=t=>"object"!=typeof t?typeof t:void 0!==t.radius?"circle":void 0!==t.width?"rect":"number"==typeof t[0]?"vector":void 0!==t.vector&&void 0!==t.origin?"line":void 0!==t[0]&&t[0].length&&"number"==typeof t[0][0]?2===t.length?"segment":"polygon":"object",dt={...o,...M,...z,...ct,...b,...Object.freeze({__proto__:null,cleanNumber:function(t,e=15){if("number"!=typeof t)return t;const r=parseFloat(t.toFixed(e));return st(r)===Math.min(e,st(t))?t:r}}),...Object.freeze({__proto__:null,smallestComparisonSearch:lt,minimum2DPointIndex:ut}),...Object.freeze({__proto__:null,sortAgainstItem:pt,sortPointsAlongVector:(t,e)=>pt(t,e,U),clusterIndicesOfSortedNumbers:mt,radialSortPointIndices2:ht}),typeof:gt},ft=[1,0,0,1],vt=ft.concat(0,0),Mt=t=>t[0]*t[3]-t[1]*t[2],_t=(t,e=[0,0])=>{const r=Math.atan2(t[1],t[0]),n=Math.cos(r),o=Math.sin(r),a=Math.cos(-r),i=Math.sin(-r),c=n*a+o*i,s=n*-i+o*a,l=o*a+-n*i,u=o*-i+-n*a;return[c,s,l,u,e[0]+c*-e[0]+-e[1]*l,e[1]+s*-e[0]+-e[1]*u]},xt=Object.freeze({__proto__:null,identity2x2:ft,identity2x3:vt,multiplyMatrix2Vector2:(t,e)=>[t[0]*e[0]+t[2]*e[1]+t[4],t[1]*e[0]+t[3]*e[1]+t[5]],multiplyMatrix2Line2:(t,e,r)=>({vector:[t[0]*e[0]+t[2]*e[1],t[1]*e[0]+t[3]*e[1]],origin:[t[0]*r[0]+t[2]*r[1]+t[4],t[1]*r[0]+t[3]*r[1]+t[5]]}),multiplyMatrices2:(t,e)=>[t[0]*e[0]+t[2]*e[1],t[1]*e[0]+t[3]*e[1],t[0]*e[2]+t[2]*e[3],t[1]*e[2]+t[3]*e[3],t[0]*e[4]+t[2]*e[5]+t[4],t[1]*e[4]+t[3]*e[5]+t[5]],determinant2:Mt,invertMatrix2:t=>{const e=Mt(t);if(!(Math.abs(e)<1e-6||Number.isNaN(e))&&Number.isFinite(t[4])&&Number.isFinite(t[5]))return[t[3]/e,-t[1]/e,-t[2]/e,t[0]/e,(t[2]*t[5]-t[3]*t[4])/e,(t[1]*t[4]-t[0]*t[5])/e]},makeMatrix2Translate:(t=0,e=0)=>ft.concat(t,e),makeMatrix2Scale:(t=[1,1],e=[0,0])=>[t[0],0,0,t[1],t[0]*-e[0]+e[0],t[1]*-e[1]+e[1]],makeMatrix2Rotate:(t,e=[0,0])=>{const r=Math.cos(t),n=Math.sin(t);return[r,n,-n,r,e[0],e[1]]},makeMatrix2Reflect:_t}),yt=Object.freeze([1,0,0,0,1,0,0,0,1]),bt=Object.freeze(yt.concat(0,0,0)),kt=(t,e)=>[t[0]*e[0]+t[3]*e[1]+t[6]*e[2],t[1]*e[0]+t[4]*e[1]+t[7]*e[2],t[2]*e[0]+t[5]*e[1]+t[8]*e[2],t[0]*e[3]+t[3]*e[4]+t[6]*e[5],t[1]*e[3]+t[4]*e[4]+t[7]*e[5],t[2]*e[3]+t[5]*e[4]+t[8]*e[5],t[0]*e[6]+t[3]*e[7]+t[6]*e[8],t[1]*e[6]+t[4]*e[7]+t[7]*e[8],t[2]*e[6]+t[5]*e[7]+t[8]*e[8],t[0]*e[9]+t[3]*e[10]+t[6]*e[11]+t[9],t[1]*e[9]+t[4]*e[10]+t[7]*e[11]+t[10],t[2]*e[9]+t[5]*e[10]+t[8]*e[11]+t[11]],Pt=t=>t[0]*t[4]*t[8]-t[0]*t[7]*t[5]-t[3]*t[1]*t[8]+t[3]*t[7]*t[2]+t[6]*t[1]*t[5]-t[6]*t[4]*t[2],Ot=(t,e,r,n,o)=>{const a=yt.concat([0,1,2].map((t=>e[t]||0))),i=Math.cos(t),c=Math.sin(t);return a[3*r+r]=i,a[3*r+n]=(o?1:-1)*c,a[3*n+r]=(o?-1:1)*c,a[3*n+n]=i,a},zt=Object.freeze({__proto__:null,identity3x3:yt,identity3x4:bt,isIdentity3x4:e=>bt.map(((r,n)=>Math.abs(r-e[n])<t)).reduce(((t,e)=>t&&e),!0),multiplyMatrix3Vector3:(t,e)=>[t[0]*e[0]+t[3]*e[1]+t[6]*e[2]+t[9],t[1]*e[0]+t[4]*e[1]+t[7]*e[2]+t[10],t[2]*e[0]+t[5]*e[1]+t[8]*e[2]+t[11]],multiplyMatrix3Line3:(t,e,r)=>({vector:[t[0]*e[0]+t[3]*e[1]+t[6]*e[2],t[1]*e[0]+t[4]*e[1]+t[7]*e[2],t[2]*e[0]+t[5]*e[1]+t[8]*e[2]],origin:[t[0]*r[0]+t[3]*r[1]+t[6]*r[2]+t[9],t[1]*r[0]+t[4]*r[1]+t[7]*r[2]+t[10],t[2]*r[0]+t[5]*r[1]+t[8]*r[2]+t[11]]}),multiplyMatrices3:kt,determinant3:Pt,invertMatrix3:t=>{const e=Pt(t);if(Math.abs(e)<1e-6||Number.isNaN(e)||!Number.isFinite(t[9])||!Number.isFinite(t[10])||!Number.isFinite(t[11]))return;const r=[t[4]*t[8]-t[7]*t[5],-t[1]*t[8]+t[7]*t[2],t[1]*t[5]-t[4]*t[2],-t[3]*t[8]+t[6]*t[5],t[0]*t[8]-t[6]*t[2],-t[0]*t[5]+t[3]*t[2],t[3]*t[7]-t[6]*t[4],-t[0]*t[7]+t[6]*t[1],t[0]*t[4]-t[3]*t[1],-t[3]*t[7]*t[11]+t[3]*t[8]*t[10]+t[6]*t[4]*t[11]-t[6]*t[5]*t[10]-t[9]*t[4]*t[8]+t[9]*t[5]*t[7],t[0]*t[7]*t[11]-t[0]*t[8]*t[10]-t[6]*t[1]*t[11]+t[6]*t[2]*t[10]+t[9]*t[1]*t[8]-t[9]*t[2]*t[7],-t[0]*t[4]*t[11]+t[0]*t[5]*t[10]+t[3]*t[1]*t[11]-t[3]*t[2]*t[10]-t[9]*t[1]*t[5]+t[9]*t[2]*t[4]],n=1/e;return r.map((t=>t*n))},makeMatrix3Translate:(t=0,e=0,r=0)=>yt.concat(t,e,r),makeMatrix3RotateX:(t,e=[0,0,0])=>Ot(t,e,1,2,!0),makeMatrix3RotateY:(t,e=[0,0,0])=>Ot(t,e,0,2,!1),makeMatrix3RotateZ:(t,e=[0,0,0])=>Ot(t,e,0,1,!0),makeMatrix3Rotate:(t,e=[0,0,1],r=[0,0,0])=>{const n=[0,1,2].map((t=>r[t]||0)),[o,a,i]=nt(3,N(e)),c=Math.cos(t),s=Math.sin(t),l=1-c,u=yt.concat(-n[0],-n[1],-n[2]),p=yt.concat(n[0],n[1],n[2]);return kt(p,kt([l*o*o+c,l*a*o+i*s,l*i*o-a*s,l*o*a-i*s,l*a*a+c,l*i*a+o*s,l*o*i+a*s,l*a*i-o*s,l*i*i+c,0,0,0],u))},makeMatrix3Scale:(t=[1,1,1],e=[0,0,0])=>[t[0],0,0,0,t[1],0,0,0,t[2],t[0]*-e[0]+e[0],t[1]*-e[1]+e[1],t[2]*-e[2]+e[2]],makeMatrix3ReflectZ:(t,e=[0,0])=>{const r=_t(t,e);return[r[0],r[1],0,r[2],r[3],0,0,0,1,r[4],r[5],0]}}),jt=Object.freeze([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),At=(t,e)=>[t[0]*e[0]+t[4]*e[1]+t[8]*e[2]+t[12]*e[3],t[1]*e[0]+t[5]*e[1]+t[9]*e[2]+t[13]*e[3],t[2]*e[0]+t[6]*e[1]+t[10]*e[2]+t[14]*e[3],t[3]*e[0]+t[7]*e[1]+t[11]*e[2]+t[15]*e[3],t[0]*e[4]+t[4]*e[5]+t[8]*e[6]+t[12]*e[7],t[1]*e[4]+t[5]*e[5]+t[9]*e[6]+t[13]*e[7],t[2]*e[4]+t[6]*e[5]+t[10]*e[6]+t[14]*e[7],t[3]*e[4]+t[7]*e[5]+t[11]*e[6]+t[15]*e[7],t[0]*e[8]+t[4]*e[9]+t[8]*e[10]+t[12]*e[11],t[1]*e[8]+t[5]*e[9]+t[9]*e[10]+t[13]*e[11],t[2]*e[8]+t[6]*e[9]+t[10]*e[10]+t[14]*e[11],t[3]*e[8]+t[7]*e[9]+t[11]*e[10]+t[15]*e[11],t[0]*e[12]+t[4]*e[13]+t[8]*e[14]+t[12]*e[15],t[1]*e[12]+t[5]*e[13]+t[9]*e[14]+t[13]*e[15],t[2]*e[12]+t[6]*e[13]+t[10]*e[14]+t[14]*e[15],t[3]*e[12]+t[7]*e[13]+t[11]*e[14]+t[15]*e[15]],Ct=t=>{const e=t[10]*t[15]-t[11]*t[14],r=t[9]*t[15]-t[11]*t[13],n=t[9]*t[14]-t[10]*t[13],o=t[8]*t[15]-t[11]*t[12],a=t[8]*t[14]-t[10]*t[12],i=t[8]*t[13]-t[9]*t[12];return t[0]*(t[5]*e-t[6]*r+t[7]*n)-t[1]*(t[4]*e-t[6]*o+t[7]*a)+t[2]*(t[4]*r-t[5]*o+t[7]*i)-t[3]*(t[4]*n-t[5]*a+t[6]*i)},Lt=Object.freeze([1,0,0,0,0,1,0,0,0,0,1,0]),wt=(t=0,e=0,r=0)=>[...Lt,t,e,r,1],Nt=(t,e,r,n,o)=>{const a=wt(...e),i=Math.cos(t),c=Math.sin(t);return a[4*r+r]=i,a[4*r+n]=(o?1:-1)*c,a[4*n+r]=(o?-1:1)*c,a[4*n+n]=i,a},St=Object.freeze({__proto__:null,identity4x4:jt,isIdentity4x4:e=>jt.map(((r,n)=>Math.abs(r-e[n])<t)).reduce(((t,e)=>t&&e),!0),multiplyMatrix4Vector3:(t,e)=>[t[0]*e[0]+t[4]*e[1]+t[8]*e[2]+t[12],t[1]*e[0]+t[5]*e[1]+t[9]*e[2]+t[13],t[2]*e[0]+t[6]*e[1]+t[10]*e[2]+t[14]],multiplyMatrix4Line3:(t,e,r)=>({vector:[t[0]*e[0]+t[4]*e[1]+t[8]*e[2],t[1]*e[0]+t[5]*e[1]+t[9]*e[2],t[2]*e[0]+t[6]*e[1]+t[10]*e[2]],origin:[t[0]*r[0]+t[4]*r[1]+t[8]*r[2]+t[12],t[1]*r[0]+t[5]*r[1]+t[9]*r[2]+t[13],t[2]*r[0]+t[6]*r[1]+t[10]*r[2]+t[14]]}),multiplyMatrices4:At,determinant4:Ct,invertMatrix4:t=>{const e=Ct(t);if(Math.abs(e)<1e-6||Number.isNaN(e)||!Number.isFinite(t[12])||!Number.isFinite(t[13])||!Number.isFinite(t[14]))return;const r=t[10]*t[15]-t[11]*t[14],n=t[9]*t[15]-t[11]*t[13],o=t[9]*t[14]-t[10]*t[13],a=t[8]*t[15]-t[11]*t[12],i=t[8]*t[14]-t[10]*t[12],c=t[8]*t[13]-t[9]*t[12],s=t[6]*t[15]-t[7]*t[14],l=t[5]*t[15]-t[7]*t[13],u=t[5]*t[14]-t[6]*t[13],p=t[6]*t[11]-t[7]*t[10],m=t[5]*t[11]-t[7]*t[9],h=t[5]*t[10]-t[6]*t[9],g=t[4]*t[15]-t[7]*t[12],d=t[4]*t[14]-t[6]*t[12],f=t[4]*t[11]-t[7]*t[8],v=t[4]*t[10]-t[6]*t[8],M=t[4]*t[13]-t[5]*t[12],_=t[4]*t[9]-t[5]*t[8],x=[+(t[5]*r-t[6]*n+t[7]*o),-(t[1]*r-t[2]*n+t[3]*o),+(t[1]*s-t[2]*l+t[3]*u),-(t[1]*p-t[2]*m+t[3]*h),-(t[4]*r-t[6]*a+t[7]*i),+(t[0]*r-t[2]*a+t[3]*i),-(t[0]*s-t[2]*g+t[3]*d),+(t[0]*p-t[2]*f+t[3]*v),+(t[4]*n-t[5]*a+t[7]*c),-(t[0]*n-t[1]*a+t[3]*c),+(t[0]*l-t[1]*g+t[3]*M),-(t[0]*m-t[1]*f+t[3]*_),-(t[4]*o-t[5]*i+t[6]*c),+(t[0]*o-t[1]*i+t[2]*c),-(t[0]*u-t[1]*d+t[2]*M),+(t[0]*h-t[1]*v+t[2]*_)],y=1/e;return x.map((t=>t*y))},makeMatrix4Translate:wt,makeMatrix4RotateX:(t,e=[0,0,0])=>Nt(t,e,1,2,!0),makeMatrix4RotateY:(t,e=[0,0,0])=>Nt(t,e,0,2,!1),makeMatrix4RotateZ:(t,e=[0,0,0])=>Nt(t,e,0,1,!0),makeMatrix4Rotate:(t,e=[0,0,1],r=[0,0,0])=>{const n=[0,1,2].map((t=>r[t]||0)),[o,a,i]=nt(3,N(e)),c=Math.cos(t),s=Math.sin(t),l=1-c,u=wt(-n[0],-n[1],-n[2]),p=wt(n[0],n[1],n[2]);return At(p,At([l*o*o+c,l*a*o+i*s,l*i*o-a*s,0,l*o*a-i*s,l*a*a+c,l*i*a+o*s,0,l*o*i+a*s,l*a*i-o*s,l*i*i+c,0,0,0,0,1],u))},makeMatrix4Scale:(t=[1,1,1],e=[0,0,0])=>[t[0],0,0,0,0,t[1],0,0,0,0,t[2],0,t[0]*-e[0]+e[0],t[1]*-e[1]+e[1],t[2]*-e[2]+e[2],1],makeMatrix4ReflectZ:(t,e=[0,0])=>{const r=_t(t,e);return[r[0],r[1],0,0,r[2],r[3],0,0,0,0,1,0,r[4],r[5],0,1]},makePerspectiveMatrix4:(t,e,r,n)=>{const o=Math.tan(.5*Math.PI-.5*t),a=1/(r-n);return[o/e,0,0,0,0,o,0,0,0,0,(r+n)*a,-1,0,0,r*n*a*2,0]},makeOrthographicMatrix4:(t,e,r,n,o,a)=>[2/(e-n),0,0,0,0,2/(t-r),0,0,0,0,2/(o-a),0,(n+e)/(n-e),(r+t)/(r-t),(o+a)/(o-a),1],makeLookAtMatrix4:(t,e,r)=>{const n=R(Z(t,e)),o=R(Q(r,n)),a=R(Q(n,o));return[o[0],o[1],o[2],0,a[0],a[1],a[2],0,n[0],n[1],n[2],0,t[0],t[1],t[2],1]}}),Rt={...ot,...xt,...zt,...St,...Object.freeze({__proto__:null,quaternionFromTwoVectors:(t,e)=>{const r=Q(t,e),n=[r[0],r[1],r[2],U(t,e)];return n[3]+=A(n),N(n)},matrix4FromQuaternion:t=>At([t[3],t[2],-t[1],t[0],-t[2],t[3],t[0],t[1],t[1],-t[0],t[3],t[2],-t[0],-t[1],-t[2],t[3]],[t[3],t[2],-t[1],-t[0],-t[2],t[3],t[0],-t[1],t[1],-t[0],t[3],-t[2],t[0],t[1],t[2],t[3]])})},It=(t,e)=>{for(;t<0;)t+=n;for(;e<0;)e+=n;for(;t>n;)t-=n;for(;e>n;)e-=n;const r=t-e;return r>=0?r:n-(e-t)},qt=(t,e)=>{for(;t<0;)t+=n;for(;e<0;)e+=n;for(;t>n;)t-=n;for(;e>n;)e-=n;const r=e-t;return r>=0?r:n-(t-e)},Ft=(t,e)=>{const r=e[0]*t[0]+e[1]*t[1],o=e[0]*t[1]-e[1]*t[0];let a=Math.atan2(o,r);return a<0&&(a+=n),a},Tt=(t,e)=>{const r=t[0]*e[0]+t[1]*e[1],o=t[0]*e[1]-t[1]*e[0];let a=Math.atan2(o,r);return a<0&&(a+=n),a},Et=(t,e)=>it(at(t)-Ft(t,e)/2),Bt=(t,e,r)=>{const n=It(t,e)/r;return Array.from(Array(r-1)).map(((e,r)=>t+n*(r+1)))},Vt=(t,e,r)=>{const n=qt(t,e)/r;return Array.from(Array(r-1)).map(((e,r)=>t+n*(r+1)))},Dt=(t,e,r)=>{const n=Math.atan2(t[1],t[0]),o=Math.atan2(e[1],e[0]);return Vt(n,o,r).map(it)},Zt=function(){const t=Array.from(arguments).flat(),e=t.map(((t,e)=>e)).sort(((e,r)=>t[e]-t[r]));return e.slice(e.indexOf(0),e.length).concat(e.slice(0,e.indexOf(0)))},Ut=function(){const t=Array.from(arguments).flat();return Zt(t).map((e=>t[e])).map(((t,e,r)=>[t,r[(e+1)%r.length]])).map((t=>qt(t[0],t[1])))},$t=(e,r,n,o=t)=>{const i=S(D(r,e)),c=S(D(n,e)),s=H(i,c);return a(s,0,o)?a(G(e,r)+G(r,n),G(e,n))?0:void 0:Math.sign(s)},Xt=Object.freeze({__proto__:null,isCounterClockwiseBetween:(t,e,r)=>{for(;r<e;)r+=n;for(;t>e;)t-=n;for(;t<e;)t+=n;return t<r},clockwiseAngleRadians:It,counterClockwiseAngleRadians:qt,clockwiseAngle2:Ft,counterClockwiseAngle2:Tt,clockwiseBisect2:Et,counterClockwiseBisect2:(t,e)=>it(at(t)+Tt(t,e)/2),clockwiseSubsectRadians:Bt,counterClockwiseSubsectRadians:Vt,clockwiseSubsect2:(t,e,r)=>{const n=Math.atan2(t[1],t[0]),o=Math.atan2(e[1],e[0]);return Bt(n,o,r).map(it)},counterClockwiseSubsect2:Dt,counterClockwiseOrderRadians:Zt,counterClockwiseOrder2:function(){return Zt(x(arguments).map(at))},counterClockwiseSectorsRadians:Ut,counterClockwiseSectors2:function(){return Ut(x(arguments).map(at))},threePointTurnDirection:$t}),Yt=Object.freeze({__proto__:null,convexHull:(e=[],r=!1,n=t)=>{if(e.length<2)return[];const o=ht(e,n).map((t=>1===t.length?t:(t=>t.concat(t.slice(0,-1).reverse()))(t))).flat();o.push(o[0]);const a=[o[0]];let i=1;const c={"-1":()=>a.pop(),1:t=>{a.push(t),i+=1},undefined:()=>{i+=1}};for(c[0]=r?c[1]:c[-1];i<o.length;){if(a.length<2){a.push(o[i]),i+=1;continue}const t=a[a.length-2],r=a[a.length-1],s=o[i];c[$t(...[t,r,s].map((t=>e[t])),n)](s)}return a.pop(),a}}),Ht=(e,r,n,o=t)=>{const a=U(e.vector,r.vector),i=H(e.vector,r.vector),c=H(D(r.origin,e.origin),r.vector)/i,s=[e.vector,r.vector].map((t=>N(t))),l=(i>-o?[[e.vector,r.vector],[J(r.vector),e.vector]]:[[r.vector,e.vector],[J(e.vector),r.vector]]).map((t=>Dt(t[0],t[1],n))),u=Math.abs(H(...s))<o,p=u?void 0:E(e.origin,q(e.vector,c)),m=Array.from(Array(n-1)),h=u?m.map(((t,o)=>Y(e.origin,r.origin,(o+1)/n))):m.map((()=>p)),g=l.map((t=>t.map(((t,e)=>({vector:t,origin:[...h[e]]})))));return u&&(g[a>-o?1:0]=[]),g},Qt=Object.freeze({__proto__:null,collinearBetween:(e,r,n,o=!1,i=t)=>{if([e,n].map((t=>c(r,t))).reduce(((t,e)=>t||e),!1))return o;const s=[[e,r],[r,n]].map((t=>V(t[1],t[0]))).map((t=>N(t)));return a(1,U(...s),i)},lerpLines:(t,e,r)=>({vector:Y(t.vector,e.vector,r),origin:Y(t.origin,e.origin,r)}),pleat:Ht,bisectLines2:(e,r,n=t)=>{const o=Ht(e,r,2,n).map((t=>t[0]));return o.forEach(((t,e)=>{void 0===t&&delete o[e]})),o}}),Wt=({vector:e,origin:r},n,o=f,a=t)=>{r=nt(e.length,r),n=nt(e.length,n);const i=w(e),c=V(n,r),s=o(U(e,c)/i,a);return T(r,I(e,s))},Gt=Object.freeze({__proto__:null,nearestPoint2:(t,e)=>{const r=lt(t,e,G);return void 0===r?void 0:t[r]},nearestPoint:(t,e)=>{const r=lt(t,e,W);return void 0===r?void 0:t[r]},nearestPointOnLine:Wt,nearestPointOnPolygon:(t,e)=>t.map(((t,e,r)=>V(r[(e+1)%r.length],t))).map(((e,r)=>({vector:e,origin:t[r]}))).map((t=>Wt(t,e,v))).map(((t,r)=>({point:t,edge:r,distance:W(t,e)}))).sort(((t,e)=>t.distance-e.distance)).shift(),nearestPointOnCircle:({radius:t,origin:e},r)=>T(e,I(N(V(r,e)),t))}),Jt=t=>Array.from(Array(Math.floor(t))).map(((e,r)=>n*(r/t))),Kt=(t,e)=>t.map((t=>[e*Math.cos(t),e*Math.sin(t)])),te=(t=3,e=1)=>Kt(Jt(t),e),ee=(t=3,e=1)=>{const r=Math.PI/t,n=Jt(t).map((t=>t+r));return Kt(n,e)},re=t=>.5*t.map(((t,e,r)=>[t,r[(e+1)%r.length]])).map((t=>H(...t))).reduce(((t,e)=>t+e),0),ne=Object.freeze({__proto__:null,makePolygonCircumradius:te,makePolygonCircumradiusSide:ee,makePolygonInradius:(t=3,e=1)=>te(t,e/Math.cos(Math.PI/t)),makePolygonInradiusSide:(t=3,e=1)=>ee(t,e/Math.cos(Math.PI/t)),makePolygonSideLength:(t=3,e=1)=>te(t,e/2/Math.sin(Math.PI/t)),makePolygonSideLengthSide:(t=3,e=1)=>ee(t,e/2/Math.sin(Math.PI/t)),makePolygonNonCollinear:(e,r=t)=>{const n=e.map(((t,e,r)=>[t,r[(e+1)%r.length]])).map((t=>V(t[1],t[0]))).map(((t,e,r)=>[t,r[(e+r.length-1)%r.length]])).map((t=>!rt(t[1],t[0],r)));return e.filter(((t,e)=>n[e]))},circumcircle:(e,r,n)=>{const o=r[0]-e[0],a=r[1]-e[1],i=n[0]-e[0],c=n[1]-e[1],s=o*(e[0]+r[0])+a*(e[1]+r[1]),l=i*(e[0]+n[0])+c*(e[1]+n[1]),u=2*(o*(n[1]-r[1])-a*(n[0]-r[0]));if(Math.abs(u)<t){const t=Math.min(e[0],r[0],n[0]),o=Math.min(e[1],r[1],n[1]),a=.5*(Math.max(e[0],r[0],n[0])-t),i=.5*(Math.max(e[1],r[1],n[1])-o);return{origin:[t+a,o+i],radius:Math.sqrt(a*a+i*i)}}const p=[(c*s-a*l)/u,(o*l-i*s)/u],m=p[0]-e[0],h=p[1]-e[1];return{origin:p,radius:Math.sqrt(m*m+h*h)}},signedArea:re,centroid:t=>{const e=1/(6*re(t));return t.map(((t,e,r)=>[t,r[(e+1)%r.length]])).map((t=>q(E(...t),H(...t)))).reduce(((t,e)=>E(t,e)),[0,0]).map((t=>t*e))},boundingBox:(t,e=0)=>{if(!t||!t.length)return;const r=Array(t[0].length).fill(1/0),n=Array(t[0].length).fill(-1/0);t.forEach((t=>t.forEach(((t,o)=>{t<r[o]&&(r[o]=t-e),t>n[o]&&(n[o]=t+e)}))));const o=n.map(((t,e)=>t-r[e]));return{min:r,max:n,span:o}}}),oe=({vector:e,origin:r},n,o=p,a=t)=>{const i=D(n,r),c=w(e),s=Math.sqrt(c);if(s<a)return!1;const l=H(i,e.map((t=>t/s))),u=$(i,e)/c;return Math.abs(l)<a&&o(u,a/s)},ae=(e,r,n=l,o=t)=>e.map(((t,e,r)=>[t,r[(e+1)%r.length]])).map((t=>H(S(D(t[1],t[0])),D(r,t[0])))).map((t=>n(t,o))).map(((t,e,r)=>t===r[0])).reduce(((t,e)=>t&&e),!0),ie=Object.freeze({__proto__:null,overlapLinePoint:oe,overlapLineLine:(e,r,n=p,o=p,a=t)=>{const i=H(e.vector,r.vector),c=-i,s=D(r.origin,e.origin),l=[-s[0],-s[1]];if(Math.abs(i)<a){if(Math.abs(H(s,e.vector))>a)return!1;const t=l,i=E(t,e.vector),c=s,u=E(c,r.vector),p=$(e.vector,e.vector),m=$(e.vector,e.vector),h=$(t,r.vector)/m,g=$(i,r.vector)/m,d=$(c,e.vector)/p,f=$(u,e.vector)/p;return n(d,a)||n(f,a)||o(h,a)||o(g,a)}const u=H(s,r.vector)/i,m=H(l,e.vector)/c;return n(u,a/C(e.vector))&&o(m,a/C(r.vector))},overlapCirclePoint:({radius:e,origin:r},n,o=l,a=t)=>o(e-G(r,n),a),overlapConvexPolygonPoint:ae,overlapConvexPolygons:(e,r,n=t)=>{for(let t=0;t<2;t+=1){const o=0===t?e:r,a=0===t?r:e;for(let t=0;t<o.length;t+=1){const e=o[t],r=K(D(o[(t+1)%o.length],o[t])),i=a.map((t=>D(t,e))).map((t=>$(r,t))),c=o[(t+2)%o.length],s=$(r,D(c,e))>0;if(i.map((t=>s?t<n:t>-n)).reduce(((t,e)=>t&&e),!0))return!1}}return!0},overlapBoundingBoxes:(e,r,n=t)=>{const o=Math.min(e.min.length,r.min.length);for(let t=0;t<o;t+=1)if(e.min[t]>r.max[t]+n||e.max[t]<r.min[t]-n)return!1;return!0}}),ce=(e,r,n=u,o=u,a=t)=>{const i=H(S(e.vector),S(r.vector));if(Math.abs(i)<a)return;const c=H(e.vector,r.vector),s=-c,l=[r.origin[0]-e.origin[0],r.origin[1]-e.origin[1]],p=[-l[0],-l[1]],m=H(l,r.vector)/c,h=H(p,e.vector)/s;return n(m,a/C(e.vector))&&o(h,a/C(r.vector))?E(e.origin,q(e.vector,m)):void 0},se=(t,e,r)=>{const n=e[0]-t[0],o=e[1]-t[1],a=n*Math.cos(r)+o*Math.sin(r),i=o*Math.cos(r)-n*Math.sin(r);return[t[0]+a,t[1]+i]},le=t=>{for(let e=1;e<t.length;e+=1)if(!c(t[0],t[e]))return[t[0],t[e]]},ue=(e,{vector:r,origin:n},o=g,a=u,i=t)=>{const c=e.map(((t,e,r)=>[t,r[(e+1)%r.length]])).map((t=>ce({vector:D(t[1],t[0]),origin:t[0]},{vector:r,origin:n},o,a,i))).filter((t=>void 0!==t));switch(c.length){case 0:return;case 1:return[c];default:return le(c)||[c[0]]}},pe=Object.freeze({__proto__:null,intersectLineLine:ce,intersectCircleLine:(e,r,n=s,o=u,a=t)=>{const i=r.vector[0]**2+r.vector[1]**2,c=Math.sqrt(i),l=0===c?r.vector:r.vector.map((t=>t/c)),p=K(l),m=D(r.origin,e.origin),h=H(m,l);if(Math.abs(h)>e.radius+a)return;const g=Math.sqrt(e.radius**2-h**2),d=(t,r)=>e.origin[r]-p[r]*h+l[r]*t,f=Math.abs(e.radius-Math.abs(h))<a?[g].map((t=>[t,t].map(d))):[-g,g].map((t=>[t,t].map(d))),v=f.map((t=>t.map(((t,e)=>t-r.origin[e])))).map((t=>t[0]*r.vector[0]+r.vector[1]*t[1])).map((t=>t/i));return f.filter(((t,e)=>o(v[e],a)))},intersectCircleCircle:(e,r,n=s,o=s,a=t)=>{const i=e.radius<r.radius?e.radius:r.radius,c=e.radius<r.radius?r.radius:e.radius,l=e.radius<r.radius?e.origin:r.origin,u=e.radius<r.radius?r.origin:e.origin,p=[l[0]-u[0],l[1]-u[1]],m=Math.sqrt(p[0]**2+p[1]**2);if(m<a)return;const h=p.map(((t,e)=>t/m*c+u[e]));if(Math.abs(c+i-m)<a||Math.abs(c-(i+m))<a)return[h];if(m+i<c||c+i<m)return;const g=(d=(i*i-m*m-c*c)/(-2*m*c))>=1?0:d<=-1?Math.PI:Math.acos(d);var d;return[se(u,h,+g),se(u,h,-g)]},intersectConvexPolygonLine:(e,{vector:r,origin:n},o=g,a=p,i=t)=>{const c=ue(e,{vector:r,origin:n},o,a,i);let s;switch(a){case h:s=m;break;case d:s=g;break;default:return c}const u=ue(e,{vector:r,origin:n},g,s,i);if(void 0===u)return;const f=le(u);if(void 0===f)switch(a){case h:return ae(e,n,l,i)?u:void 0;case d:return ae(e,E(n,r),l,i)||ae(e,n,l,i)?u:void 0;default:return}return ae(e,X(...f),l,i)?f:c}}),me=(t,e,r)=>{const n=t.map(((t,e)=>({vector:r[e],origin:t}))).map(((t,e,r)=>ce(t,r[(e+1)%r.length],h,h))),o=e.map(((t,e)=>Wt(t,n[e],(t=>t))));if(3===t.length)return t.map((t=>({type:"skeleton",points:[t,n[0]]}))).concat([{type:"perpendicular",points:[o[0],n[0]]}]);const a=n.map(((t,e)=>W(t,o[e])));let i=0;a.forEach(((t,e)=>{t<a[i]&&(i=e)}));const c=[{type:"skeleton",points:[t[i],n[i]]},{type:"skeleton",points:[t[(i+1)%t.length],n[i]]},{type:"perpendicular",points:[o[i],n[i]]}],s=Et(J(e[(i+e.length-1)%e.length].vector),e[(i+1)%e.length].vector),l=i===t.length-1;return t.splice(i,2,n[i]),e.splice(i,1),r.splice(i,2,s),l&&(t.splice(0,1),r.splice(0,1),e.push(e.shift())),c.concat(me(t,e,r))},he={...Yt,...Qt,...Gt,...ne,...Xt,straightSkeleton:t=>{const e=t.map(((t,e,r)=>[t,r[(e+1)%r.length]])).map((t=>({vector:V(t[1],t[0]),origin:t[0]}))),r=t.map(((t,e,r)=>[(e-1+r.length)%r.length,e,(e+1)%r.length].map((t=>r[t])))).map((t=>[V(t[0],t[1]),V(t[2],t[1])])).map((t=>Et(...t)));return me([...t],e,r)}},ge=Object.freeze({__proto__:null,enclosingBoundingBoxes:(e,r,n=t)=>{const o=Math.min(e.min.length,r.min.length);for(let t=0;t<o;t+=1)if(r.min[t]<e.min[t]-n||r.max[t]>e.max[t]+n)return!1;return!0},enclosingPolygonPolygon:(t,e,r=s)=>{const n=t.map((t=>ae(e,t,r))).reduce(((t,e)=>t||e),!1),o=e.map((t=>ae(e,t,r))).reduce(((t,e)=>t&&e),!0);return!n&&o}}),de=(t,e,r)=>E(e,q(t,r)),fe=(e,r,n,o,a)=>e.map(((t,e,r)=>[D(r[(e+1)%r.length],t),t])).map((e=>((e,r,n,o,a=g,i=t)=>{const c=H(S(e),S(n));if(Math.abs(c)<i)return;const s=H(e,n),l=-s,u=D(o,r),p=J(u),m=H(u,n)/s;return a(H(p,e)/l,i/C(n))?m:void 0})(r,n,e[0],e[1],o,a))).filter((t=>void 0!==t)).sort(((t,e)=>t-e)),ve=Object.freeze({__proto__:null,clipLineConvexPolygon:(e,{vector:r,origin:n},o=s,a=u,i=t)=>{const c=fe(e,r,n,g,i);if(c.length<2)return;const l=((t,e,r)=>{let n=0,o=t.length-1;for(;n<o&&!e(t[n+1]-t[n],r);)n+=1;for(;o>n&&!e(t[o]-t[o-1],r);)o-=1;if(!(n>=o))return[t[n],t[o]]})(c,o,2*i/C(r));if(void 0===l)return;const p=l.map((t=>a(t)?t:t<.5?0:1));if(Math.abs(p[0]-p[1])<2*i/C(r))return;const m=de(r,n,(p[0]+p[1])/2);return ae(e,m,o,i)?p.map((t=>de(r,n,t))):void 0},clipPolygonPolygon:(e,r,n=t)=>{const o=(t,e,r)=>(r[0]-e[0])*(t[1]-e[1])>(r[1]-e[1])*(t[0]-e[0])+n,a=(t,e,r,n)=>{const o=D(t,e),a=D(n,r),i=H(t,e),c=H(n,r),s=1/H(o,a);return q(D(q(a,i),q(o,c)),s)};let i=e,c=r[r.length-1];for(let t=0;t<r.length;t+=1){const e=r[t],n=i;i=[];let s=n[n.length-1];for(let t=0;t<n.length;t+=1){const r=n[t];o(r,c,e)?(o(s,c,e)||i.push(a(c,e,r,s)),i.push(r)):o(s,c,e)&&i.push(a(c,e,r,s)),s=r}c=e}return 0===i.length?void 0:i}}),Me=Object.freeze({__proto__:null,splitConvexPolygon:(t,e)=>{const r=t.map(((t,r)=>({point:oe(e,t,u)?t:null,at_index:r}))).filter((t=>null!=t.point)),n=t.map(((t,e,r)=>({vector:V(t,r[(e+1)%r.length]),origin:r[(e+1)%r.length]}))).map(((t,r)=>({point:ce(e,t,p,d),at_index:r}))).filter((t=>null!=t.point));if(2===n.length){const e=n.slice().sort(((t,e)=>t.at_index-e.at_index)),r=t.slice(e[1].at_index+1).concat(t.slice(0,e[0].at_index+1));r.push(e[0].point),r.push(e[1].point);const o=t.slice(e[0].at_index+1,e[1].at_index+1);return o.push(e[1].point),o.push(e[0].point),[r,o]}if(1===n.length&&1===r.length){r[0].type="v",n[0].type="e";const e=r.concat(n).sort(((t,e)=>t.at_index-e.at_index)),o=t.slice(e[1].at_index+1).concat(t.slice(0,e[0].at_index+1));"e"===e[0].type&&o.push(e[0].point),o.push(e[1].point);const a=t.slice(e[0].at_index+1,e[1].at_index+1);return"e"===e[1].type&&a.push(e[1].point),a.push(e[0].point),[o,a]}if(2===r.length){const e=r.slice().sort(((t,e)=>t.at_index-e.at_index));return[t.slice(e[1].at_index).concat(t.slice(0,e[0].at_index+1)),t.slice(e[0].at_index,e[1].at_index+1)]}return[t.slice()]}}),_e={polygon:g,circle:s,line:u,ray:m,segment:g};return{...dt,...Rt,...he,...{...ge,...ie,...pe,...ve,...Me,intersect:(e,r,n=t)=>{const o=t=>"polygon"===t?"ConvexPolygon":(t=>t.charAt(0).toUpperCase()+t.slice(1))(t),a=[e,r].map(gt),i=[a,a.slice().reverse()].map((t=>t.map(o).join(""))).map((t=>pe[`intersect${t}`])),c=[e.domain,r.domain].map(((t,e)=>t||_e[a[e]])),s=[[e,r,...c],[r,e,...c.slice().reverse()]],l=i.map(((t,e)=>({fn:t,params:s[e]}))).filter((t=>t.fn)).shift();return l?l.fn(...l.params,n):void 0}}}}));