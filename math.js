!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?module.exports=n():"function"==typeof define&&define.amd?define(n):(t="undefined"!=typeof globalThis?globalThis:t||self).math=n()}(this,(function(){"use strict";const t=1e-6,n=180/Math.PI,e=Math.PI/180,r=2*Math.PI,i=Object.freeze({__proto__:null,D2R:e,EPSILON:t,R2D:n,TWO_PI:r}),o=(n,e,r=t)=>Math.abs(n-e)<r,s=(n,e,r=t)=>o(n,e,r)?0:Math.sign(n-e),c=(n,e,r=t)=>{for(let t=0;t<Math.max(n.length,e.length);t+=1)if(!o(n[t]||0,e[t]||0,r))return!1;return!0},a=(n,e=t)=>n>-e,u=(n,e=t)=>n>e,h=()=>!0,l=()=>!0,p=a,f=u,m=(n,e=t)=>n>-e&&n<1+e,g=(n,e=t)=>n>e&&n<1-e,d=t=>t,v=n=>n<-t?0:n,y=n=>n<-t?0:n>1.000001?1:n,M=Object.freeze({__proto__:null,clampLine:d,clampRay:v,clampSegment:y,epsilonCompare:s,epsilonEqual:o,epsilonEqualVectors:c,exclude:u,excludeL:l,excludeR:f,excludeS:g,include:a,includeL:h,includeR:p,includeS:m}),x=(t,n)=>t+(n||0),b=t=>Math.sqrt(t.map((t=>t*t)).reduce(x,0)),_=t=>Math.sqrt(t[0]*t[0]+t[1]*t[1]),P=t=>Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]),O=t=>t.map((t=>t*t)).reduce(x,0),j=t=>{const n=b(t);return 0===n?t:t.map((t=>t/n))},k=t=>{const n=_(t);return 0===n?t:[t[0]/n,t[1]/n]},A=t=>{const n=P(t);return 0===n?t:[t[0]/n,t[1]/n,t[2]/n]},w=(t,n)=>t.map((t=>t*n)),S=(t,n)=>[t[0]*n,t[1]*n],$=(t,n)=>[t[0]*n,t[1]*n,t[2]*n],z=(t,n)=>t.map(((t,e)=>t+(n[e]||0))),N=(t,n)=>[t[0]+n[0],t[1]+n[1]],I=(t,n)=>[t[0]+n[0],t[1]+n[1],t[2]+n[2]],C=(t,n)=>t.map(((t,e)=>t-(n[e]||0))),L=(t,n)=>[t[0]-n[0],t[1]-n[1]],R=(t,n)=>[t[0]-n[0],t[1]-n[1],t[2]-n[2]],E=(t,n)=>t.map(((e,r)=>t[r]*n[r])).reduce(x,0),q=(t,n)=>t[0]*n[0]+t[1]*n[1],B=(t,n)=>t[0]*n[0]+t[1]*n[1]+t[2]*n[2],T=(t,n)=>t.map(((t,e)=>(t+n[e])/2)),V=(t,n)=>S(N(t,n),.5),F=function(){if(0===arguments.length)return;const t=arguments[0].length>0?arguments[0].length:0,n=Array(t).fill(0);return Array.from(arguments).forEach((t=>n.forEach(((e,r)=>{n[r]+=t[r]||0})))),n.map((t=>t/arguments.length))},G=(t,n,e=0)=>{const r=1-e;return t.map(((t,i)=>t*r+(n[i]||0)*e))},Z=(t,n)=>t[0]*n[1]-t[1]*n[0],D=(t,n)=>[t[1]*n[2]-t[2]*n[1],t[2]*n[0]-t[0]*n[2],t[0]*n[1]-t[1]*n[0]],U=(t,n)=>Math.sqrt(t.map(((e,r)=>(t[r]-n[r])**2)).reduce(x,0)),X=(t,n)=>{const e=t[0]-n[0],r=t[1]-n[1];return Math.sqrt(e*e+r*r)},Y=t=>t.map((t=>-t)),H=t=>[-t[1],t[0]],Q=t=>[t[1],-t[0]],W=(n,e=t)=>n.map((t=>Math.abs(t))).reduce(x,0)<e,J=(n,e,r=t)=>1-Math.abs(E(n,e))<r,K=(n,e,r=t)=>J(j(n),j(e),r),tt=(t,n)=>n.length===t?n:Array(t).fill(0).map(((t,e)=>n[e]?n[e]:t)),nt=(t,n)=>[t,n].map((e=>tt(Math.max(t.length,n.length),e))),et=(t=[1,0])=>{const n=k(t);return[n,H(n)]},rt=(t=[1,0,0])=>{const n=A(t),e=[[1,0,0],[0,1,0],[0,0,1]].map((t=>D(t,n))),r=e.map(P).map(((t,n)=>({n:t,i:n}))).sort(((t,n)=>n.n-t.n)).map((t=>t.i)).shift(),i=A(e[r]);return[n,i,D(n,i)]},it=Object.freeze({__proto__:null,add:z,add2:N,add3:I,average:F,average2:(...t)=>{if(!t||!t.length)return;const n=1/t.length;return t.reduce(((t,n)=>N(t,n)),[0,0]).map((t=>t*n))},basisVectors:t=>2===t.length?et(t):rt(t),basisVectors2:et,basisVectors3:rt,cross2:Z,cross3:D,degenerate:W,distance:U,distance2:X,distance3:(t,n)=>{const e=t[0]-n[0],r=t[1]-n[1],i=t[2]-n[2];return Math.sqrt(e*e+r*r+i*i)},dot:E,dot2:q,dot3:B,flip:Y,lerp:G,magSquared:O,magnitude:b,magnitude2:_,magnitude3:P,midpoint:T,midpoint2:V,midpoint3:(t,n)=>$(I(t,n),.5),normalize:j,normalize2:k,normalize3:A,parallel:K,parallel2:(n,e,r=t)=>Math.abs(Z(n,e))<r,parallelNormalized:J,resize:tt,resizeUp:nt,rotate270:Q,rotate90:H,scale:w,scale2:S,scale3:$,subtract:C,subtract2:L,subtract3:R}),ot=[1,0,0,1],st=ot.concat(0,0),ct=t=>t[0]*t[3]-t[1]*t[2],at=(t=[1,1],n=[0,0])=>[t[0],0,0,t[1],t[0]*-n[0]+n[0],t[1]*-n[1]+n[1]],ut=(t,n=[0,0])=>{const e=Math.cos(t),r=Math.sin(t);return[e,r,-r,e,n[0],n[1]]},ht=(t,n=[0,0])=>{const e=Math.atan2(t[1],t[0]),r=Math.cos(e),i=Math.sin(e),o=Math.cos(-e),s=Math.sin(-e),c=r*o+i*s,a=r*-s+i*o,u=i*o+-r*s,h=i*-s+-r*o;return[c,a,u,h,n[0]+c*-n[0]+-n[1]*u,n[1]+a*-n[0]+-n[1]*h]},lt=Object.freeze({__proto__:null,determinant2:ct,identity2x2:ot,identity2x3:st,invertMatrix2:t=>{const n=ct(t);if(!(Math.abs(n)<1e-12||Number.isNaN(n))&&Number.isFinite(t[4])&&Number.isFinite(t[5]))return[t[3]/n,-t[1]/n,-t[2]/n,t[0]/n,(t[2]*t[5]-t[3]*t[4])/n,(t[1]*t[4]-t[0]*t[5])/n]},makeMatrix2Reflect:ht,makeMatrix2Rotate:ut,makeMatrix2Scale:at,makeMatrix2Translate:(t=0,n=0)=>ot.concat(t,n),makeMatrix2UniformScale:(t=1,n=[0,0])=>at([t,t],n),multiplyMatrices2:(t,n)=>[t[0]*n[0]+t[2]*n[1],t[1]*n[0]+t[3]*n[1],t[0]*n[2]+t[2]*n[3],t[1]*n[2]+t[3]*n[3],t[0]*n[4]+t[2]*n[5]+t[4],t[1]*n[4]+t[3]*n[5]+t[5]],multiplyMatrix2Line2:(t,n,e)=>({vector:[t[0]*n[0]+t[2]*n[1],t[1]*n[0]+t[3]*n[1]],origin:[t[0]*e[0]+t[2]*e[1]+t[4],t[1]*e[0]+t[3]*e[1]+t[5]]}),multiplyMatrix2Vector2:(t,n)=>[t[0]*n[0]+t[2]*n[1]+t[4],t[1]*n[0]+t[3]*n[1]+t[5]]}),pt=Object.freeze([1,0,0,0,1,0,0,0,1]),ft=Object.freeze(pt.concat(0,0,0)),mt=n=>ft.map(((e,r)=>Math.abs(e-n[r])<t)).reduce(((t,n)=>t&&n),!0),gt=(t,n)=>[t[0]*n[0]+t[3]*n[1]+t[6]*n[2]+t[9],t[1]*n[0]+t[4]*n[1]+t[7]*n[2]+t[10],t[2]*n[0]+t[5]*n[1]+t[8]*n[2]+t[11]],dt=(t,n,e)=>({vector:[t[0]*n[0]+t[3]*n[1]+t[6]*n[2],t[1]*n[0]+t[4]*n[1]+t[7]*n[2],t[2]*n[0]+t[5]*n[1]+t[8]*n[2]],origin:[t[0]*e[0]+t[3]*e[1]+t[6]*e[2]+t[9],t[1]*e[0]+t[4]*e[1]+t[7]*e[2]+t[10],t[2]*e[0]+t[5]*e[1]+t[8]*e[2]+t[11]]}),vt=(t,n)=>[t[0]*n[0]+t[3]*n[1]+t[6]*n[2],t[1]*n[0]+t[4]*n[1]+t[7]*n[2],t[2]*n[0]+t[5]*n[1]+t[8]*n[2],t[0]*n[3]+t[3]*n[4]+t[6]*n[5],t[1]*n[3]+t[4]*n[4]+t[7]*n[5],t[2]*n[3]+t[5]*n[4]+t[8]*n[5],t[0]*n[6]+t[3]*n[7]+t[6]*n[8],t[1]*n[6]+t[4]*n[7]+t[7]*n[8],t[2]*n[6]+t[5]*n[7]+t[8]*n[8],t[0]*n[9]+t[3]*n[10]+t[6]*n[11]+t[9],t[1]*n[9]+t[4]*n[10]+t[7]*n[11]+t[10],t[2]*n[9]+t[5]*n[10]+t[8]*n[11]+t[11]],yt=t=>t[0]*t[4]*t[8]-t[0]*t[7]*t[5]-t[3]*t[1]*t[8]+t[3]*t[7]*t[2]+t[6]*t[1]*t[5]-t[6]*t[4]*t[2],Mt=t=>{const n=yt(t);if(Math.abs(n)<1e-12||Number.isNaN(n)||!Number.isFinite(t[9])||!Number.isFinite(t[10])||!Number.isFinite(t[11]))return;const e=[t[4]*t[8]-t[7]*t[5],-t[1]*t[8]+t[7]*t[2],t[1]*t[5]-t[4]*t[2],-t[3]*t[8]+t[6]*t[5],t[0]*t[8]-t[6]*t[2],-t[0]*t[5]+t[3]*t[2],t[3]*t[7]-t[6]*t[4],-t[0]*t[7]+t[6]*t[1],t[0]*t[4]-t[3]*t[1],-t[3]*t[7]*t[11]+t[3]*t[8]*t[10]+t[6]*t[4]*t[11]-t[6]*t[5]*t[10]-t[9]*t[4]*t[8]+t[9]*t[5]*t[7],t[0]*t[7]*t[11]-t[0]*t[8]*t[10]-t[6]*t[1]*t[11]+t[6]*t[2]*t[10]+t[9]*t[1]*t[8]-t[9]*t[2]*t[7],-t[0]*t[4]*t[11]+t[0]*t[5]*t[10]+t[3]*t[1]*t[11]-t[3]*t[2]*t[10]-t[9]*t[1]*t[5]+t[9]*t[2]*t[4]],r=1/n;return e.map((t=>t*r))},xt=(t=0,n=0,e=0)=>pt.concat(t,n,e),bt=(t,n,e,r,i)=>{const o=Math.cos(t),s=Math.sin(t),c=pt.concat([0,0,0]);c[3*e+e]=o,c[3*e+r]=(i?1:-1)*s,c[3*r+e]=(i?-1:1)*s,c[3*r+r]=o;const a=[0,1,2].map((t=>n[t]||0)),u=pt.concat(Y(a)),h=pt.concat(a);return vt(h,vt(c,u))},_t=(t,n=[0,0,0])=>bt(t,n,1,2,!0),Pt=(t,n=[0,0,0])=>bt(t,n,0,2,!1),Ot=(t,n=[0,0,0])=>bt(t,n,0,1,!0),jt=(t,n=[0,0,1],e=[0,0,0])=>{const r=[0,1,2].map((t=>e[t]||0)),[i,o,s]=tt(3,j(n)),c=Math.cos(t),a=Math.sin(t),u=1-c,h=pt.concat(-r[0],-r[1],-r[2]),l=pt.concat(r[0],r[1],r[2]);return vt(l,vt([u*i*i+c,u*o*i+s*a,u*s*i-o*a,u*i*o-s*a,u*o*o+c,u*s*o+i*a,u*i*s+o*a,u*o*s-i*a,u*s*s+c,0,0,0],h))},kt=(t=[1,1,1],n=[0,0,0])=>[t[0],0,0,0,t[1],0,0,0,t[2],t[0]*-n[0]+n[0],t[1]*-n[1]+n[1],t[2]*-n[2]+n[2]],At=(t,n=[0,0])=>{const e=ht(t,n);return[e[0],e[1],0,e[2],e[3],0,0,0,1,e[4],e[5],0]},wt=Object.freeze({__proto__:null,determinant3:yt,identity3x3:pt,identity3x4:ft,invertMatrix3:Mt,isIdentity3x4:mt,makeMatrix3ReflectZ:At,makeMatrix3Rotate:jt,makeMatrix3RotateX:_t,makeMatrix3RotateY:Pt,makeMatrix3RotateZ:Ot,makeMatrix3Scale:kt,makeMatrix3Translate:xt,makeMatrix3UniformScale:(t=1,n=[0,0,0])=>kt([t,t,t],n),multiplyMatrices3:vt,multiplyMatrix3Line3:dt,multiplyMatrix3Vector3:gt}),St=t=>null!=t&&"function"==typeof t[Symbol.iterator],$t=function(){switch(arguments.length){case 0:return Array.from(arguments);case 1:return St(arguments[0])&&"string"!=typeof arguments[0]?$t(...arguments[0]):[arguments[0]];default:return Array.from(arguments).map((t=>St(t)?[...$t(t)]:t))}},zt=function(){switch(arguments.length){case 0:return Array.from(arguments);case 1:return St(arguments[0])&&"string"!=typeof arguments[0]?zt(...arguments[0]):[arguments[0]];default:return Array.from(arguments).map((t=>St(t)?[...zt(t)]:t)).flat()}},Nt=Object.freeze({__proto__:null,flattenArrays:zt,semiFlattenArrays:$t}),It=function(){let t=zt(arguments);const n=t[0];return"object"!=typeof n||null===n||Number.isNaN(n.x)||(t=["x","y","z"].map((t=>n[t])).filter((t=>void 0!==t))),t.filter((t=>"number"==typeof t))},Ct=function(){return $t(arguments).map((t=>It(t)))},Lt=function(){const t=$t(arguments);return 4===t.length?[[0,1],[2,3]].map((n=>n.map((n=>t[n])))):t.map((t=>It(t)))},Rt=(t,n=[])=>({vector:t,origin:n}),Et=function(){const t=$t(arguments);return 0===t.length||null==t[0]?Rt([],[]):t[0].constructor===Object&&void 0!==t[0].vector?Rt(t[0].vector,t[0].origin||[]):"number"==typeof t[0]?Rt(It(t)):Rt(...t.map((t=>It(t))))},qt=[[0,1,3,4,9,10],[0,1,2,3,4,5,6,7,8,9,10,11],[0,1,2,void 0,3,4,5,void 0,6,7,8,void 0,9,10,11]];[11,7,3].forEach((t=>delete qt[2][t]));const Bt=function(){const t=zt(arguments),n=[...ft];var e;return(e=t.length,e<8?qt[0]:e<13?qt[1]:qt[2]).forEach(((e,r)=>{null!=t[r]&&(n[e]=t[r])})),n},Tt=(t=0,n=0,e=0,r=0)=>({x:t,y:n,width:e,height:r}),Vt=function(){const t=zt(arguments);if(t.length>0&&"object"==typeof t[0]&&null!==t[0]&&!Number.isNaN(t[0].width))return Tt(...["x","y","width","height"].map((n=>t[0][n])).filter((t=>void 0!==t)));const n=t.filter((t=>"number"==typeof t)),e=n.length<4?[,,...n]:n;return Tt(...e)},Ft=(t=1,...n)=>({radius:t,origin:[...n]}),Gt=function(){const t=Ct(arguments),n=zt(arguments).filter((t=>"number"==typeof t));if(2===arguments.length){if(1===t[1].length)return Ft(t[1][0],...t[0]);if(1===t[0].length)return Ft(t[0][0],...t[1]);if(t[0].length>1&&t[1].length>1)return Ft(X(...t),...t[0])}else switch(n.length){case 0:return Ft(1,0,0,0);case 1:return Ft(n[0],0,0,0);default:return Ft(n.pop(),...n)}return Ft(1,0,0,0)},Zt=Object.freeze({__proto__:null,getArrayOfVectors:Ct,getCircle:Gt,getLine:Et,getMatrix2:function(){const t=It(arguments);return 6===t.length?t:t.length>6?[t[0],t[1],t[2],t[3],t[4],t[5]]:t.length<6?st.map(((n,e)=>t[e]||n)):[...st]},getMatrix3x4:Bt,getRect:Vt,getSegment:Lt,getVector:It,get_rect_params:Tt}),Dt=t=>Math.atan2(t[1],t[0]),Ut=t=>[Math.cos(t),Math.sin(t)],Xt=({vector:t,origin:n})=>{const e=b(t),r=H(t),i=E(n,r)/e;return{normal:w(r,1/e),distance:i}},Yt=({normal:t,distance:n})=>({vector:Q(t),origin:w(t,n)}),Ht=Object.freeze({__proto__:null,angleToVector:Ut,pointsToLine:(...t)=>{const n=Ct(...t);return{vector:C(n[1],n[0]),origin:n[0]}},uniqueLineToVecLine:Yt,vecLineToUniqueLine:Xt,vectorToAngle:Dt}),Qt=function(t){const n=`${t}`.match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);return Math.max(0,(n[1]?n[1].length:0)-(n[2]?+n[2]:0))},Wt=function(t,n=15){const e="number"==typeof t?t:parseFloat(t);if(Number.isNaN(e))return t;const r=parseFloat(e.toFixed(n));return Qt(r)===Math.min(n,Qt(e))?e:r},Jt=Object.freeze({__proto__:null,cleanNumber:Wt}),Kt=(t,n,e)=>{const r=t.map(((t,r)=>({i:r,d:e(n,t)})));let i,o=1/0;for(let t=0;t<r.length;t+=1)r[t].d<o&&(i=t,o=r[t].d);return i},tn=(n,e=t)=>{if(!n||!n.length)return;const r=((t,n,e,r)=>{let i=[0];for(let o=1;o<t.length;o+=1)switch(e(t[i[0]][n],t[o][n],r)){case 0:i.push(o);break;case 1:i=[o]}return i})(n,0,s,e);let i=0;for(let t=1;t<r.length;t+=1)n[r[t]][1]<n[r[i]][1]&&(i=t);return r[i]},nn=Object.freeze({__proto__:null,minimum2DPointIndex:tn,smallestComparisonSearch:Kt}),en=(t,n=[1,0,0],e=[0,0,0])=>{const r=tt(3,t),i=R(r,tt(3,e)),o=A(tt(3,n)),s=B(o,i),c=$(o,s);return R(r,c)},rn=Object.freeze({__proto__:null,projectPointOnPlane:en}),on=(t,n,e)=>t.map(((t,r)=>({i:r,n:e(t,n)}))).sort(((t,n)=>t.n-n.n)).map((t=>t.i)),sn=(n,e=t)=>{const r=[[0]];let i=0;for(let t=1;t<n.length;t+=1)o(n[t],n[t-1],e)?r[i].push(t):(i=r.length,r.push([t]));return r},cn=(n,e=t)=>{const r=tn(n,e);if(void 0===r)return[];const i=n.map((t=>L(t,n[r]))).map((t=>k(t))).map((t=>q([0,1],t))),o=i.map(((t,n)=>({a:t,i:n}))).sort(((t,n)=>t.a-n.a)).map((t=>t.i)).filter((t=>t!==r));return[[r]].concat(sn(o.map((t=>i[t])),e).map((t=>t.map((t=>o[t])))).map((t=>1===t.length?t:t.map((t=>({i:t,len:X(n[t],n[r])}))).sort(((t,n)=>t.len-n.len)).map((t=>t.i)))))},an=t=>{const n=[t=>t[0]>=0&&t[1]>=0,t=>t[0]<0&&t[1]>=0,t=>t[0]<0&&t[1]<0,t=>t[0]>=0&&t[1]<0],e=[(n,e)=>t[e][0]-t[n][0],(n,e)=>t[e][0]-t[n][0],(n,e)=>t[n][0]-t[e][0],(n,e)=>t[n][0]-t[e][0]],r=t.map((t=>n.map(((n,e)=>n(t)?e:void 0)).filter((t=>void 0!==t)).shift())),i=[[],[],[],[]];return r.forEach(((t,n)=>{i[t].push(n)})),i.flatMap(((t,n)=>t.sort(e[n])))},un=Object.freeze({__proto__:null,clusterIndicesOfSortedNumbers:sn,radialSortPointIndices2:cn,radialSortPointIndices3:(t,n=[1,0,0],e=[0,0,0])=>{const r=rt(n),i=[r[1],r[2],r[0]],o=t.map((t=>en(t,n,e))).map((t=>C(t,e))).map((t=>[E(t,i[0]),E(t,i[1])])).map(k);return an(o)},radialSortUnitVectors2:an,sortAgainstItem:on,sortPointsAlongVector:(t,n)=>on(t,n,E)}),hn=t=>"object"!=typeof t?typeof t:void 0!==t.radius?"circle":t.min&&t.max&&t.span?"box":"number"==typeof t[0]?"vector":void 0!==t.vector&&void 0!==t.origin?"line":void 0!==t[0]&&t[0].length&&"number"==typeof t[0][0]?2===t.length?"segment":"polygon":"object",ln={...i,...M,...Zt,...Ht,...Nt,...Jt,...nn,...un,typeof:hn},pn=Object.freeze([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),fn=(t,n)=>[t[0]*n[0]+t[4]*n[1]+t[8]*n[2]+t[12]*n[3],t[1]*n[0]+t[5]*n[1]+t[9]*n[2]+t[13]*n[3],t[2]*n[0]+t[6]*n[1]+t[10]*n[2]+t[14]*n[3],t[3]*n[0]+t[7]*n[1]+t[11]*n[2]+t[15]*n[3],t[0]*n[4]+t[4]*n[5]+t[8]*n[6]+t[12]*n[7],t[1]*n[4]+t[5]*n[5]+t[9]*n[6]+t[13]*n[7],t[2]*n[4]+t[6]*n[5]+t[10]*n[6]+t[14]*n[7],t[3]*n[4]+t[7]*n[5]+t[11]*n[6]+t[15]*n[7],t[0]*n[8]+t[4]*n[9]+t[8]*n[10]+t[12]*n[11],t[1]*n[8]+t[5]*n[9]+t[9]*n[10]+t[13]*n[11],t[2]*n[8]+t[6]*n[9]+t[10]*n[10]+t[14]*n[11],t[3]*n[8]+t[7]*n[9]+t[11]*n[10]+t[15]*n[11],t[0]*n[12]+t[4]*n[13]+t[8]*n[14]+t[12]*n[15],t[1]*n[12]+t[5]*n[13]+t[9]*n[14]+t[13]*n[15],t[2]*n[12]+t[6]*n[13]+t[10]*n[14]+t[14]*n[15],t[3]*n[12]+t[7]*n[13]+t[11]*n[14]+t[15]*n[15]],mn=t=>{const n=t[10]*t[15]-t[11]*t[14],e=t[9]*t[15]-t[11]*t[13],r=t[9]*t[14]-t[10]*t[13],i=t[8]*t[15]-t[11]*t[12],o=t[8]*t[14]-t[10]*t[12],s=t[8]*t[13]-t[9]*t[12];return t[0]*(t[5]*n-t[6]*e+t[7]*r)-t[1]*(t[4]*n-t[6]*i+t[7]*o)+t[2]*(t[4]*e-t[5]*i+t[7]*s)-t[3]*(t[4]*r-t[5]*o+t[6]*s)},gn=Object.freeze([1,0,0,0,0,1,0,0,0,0,1,0]),dn=(t=0,n=0,e=0)=>[...gn,t,n,e,1],vn=(t,n,e,r,i)=>{const o=Math.cos(t),s=Math.sin(t),c=[...pn];c[4*e+e]=o,c[4*e+r]=(i?1:-1)*s,c[4*r+e]=(i?-1:1)*s,c[4*r+r]=o;const a=[0,1,2].map((t=>n[t]||0)),u=[...pn],h=[...pn];return[12,13,14].forEach(((t,n)=>{u[t]=-a[n],h[t]=a[n]})),fn(h,fn(c,u))},yn=(t=[1,1,1],n=[0,0,0])=>[t[0],0,0,0,0,t[1],0,0,0,0,t[2],0,t[0]*-n[0]+n[0],t[1]*-n[1]+n[1],t[2]*-n[2]+n[2],1],Mn=Object.freeze({__proto__:null,determinant4:mn,identity4x4:pn,invertMatrix4:t=>{const n=mn(t);if(Math.abs(n)<1e-12||Number.isNaN(n)||!Number.isFinite(t[12])||!Number.isFinite(t[13])||!Number.isFinite(t[14]))return;const e=t[10]*t[15]-t[11]*t[14],r=t[9]*t[15]-t[11]*t[13],i=t[9]*t[14]-t[10]*t[13],o=t[8]*t[15]-t[11]*t[12],s=t[8]*t[14]-t[10]*t[12],c=t[8]*t[13]-t[9]*t[12],a=t[6]*t[15]-t[7]*t[14],u=t[5]*t[15]-t[7]*t[13],h=t[5]*t[14]-t[6]*t[13],l=t[6]*t[11]-t[7]*t[10],p=t[5]*t[11]-t[7]*t[9],f=t[5]*t[10]-t[6]*t[9],m=t[4]*t[15]-t[7]*t[12],g=t[4]*t[14]-t[6]*t[12],d=t[4]*t[11]-t[7]*t[8],v=t[4]*t[10]-t[6]*t[8],y=t[4]*t[13]-t[5]*t[12],M=t[4]*t[9]-t[5]*t[8],x=[+(t[5]*e-t[6]*r+t[7]*i),-(t[1]*e-t[2]*r+t[3]*i),+(t[1]*a-t[2]*u+t[3]*h),-(t[1]*l-t[2]*p+t[3]*f),-(t[4]*e-t[6]*o+t[7]*s),+(t[0]*e-t[2]*o+t[3]*s),-(t[0]*a-t[2]*m+t[3]*g),+(t[0]*l-t[2]*d+t[3]*v),+(t[4]*r-t[5]*o+t[7]*c),-(t[0]*r-t[1]*o+t[3]*c),+(t[0]*u-t[1]*m+t[3]*y),-(t[0]*p-t[1]*d+t[3]*M),-(t[4]*i-t[5]*s+t[6]*c),+(t[0]*i-t[1]*s+t[2]*c),-(t[0]*h-t[1]*g+t[2]*y),+(t[0]*f-t[1]*v+t[2]*M)],b=1/n;return x.map((t=>t*b))},isIdentity4x4:n=>pn.map(((e,r)=>Math.abs(e-n[r])<t)).reduce(((t,n)=>t&&n),!0),makeLookAtMatrix4:(t,n,e)=>{const r=A(R(t,n)),i=A(D(e,r)),o=A(D(r,i));return[i[0],i[1],i[2],0,o[0],o[1],o[2],0,r[0],r[1],r[2],0,t[0],t[1],t[2],1]},makeMatrix4ReflectZ:(t,n=[0,0])=>{const e=ht(t,n);return[e[0],e[1],0,0,e[2],e[3],0,0,0,0,1,0,e[4],e[5],0,1]},makeMatrix4Rotate:(t,n=[0,0,1],e=[0,0,0])=>{const r=[0,1,2].map((t=>e[t]||0)),[i,o,s]=tt(3,j(n)),c=Math.cos(t),a=Math.sin(t),u=1-c,h=dn(-r[0],-r[1],-r[2]),l=dn(r[0],r[1],r[2]);return fn(l,fn([u*i*i+c,u*o*i+s*a,u*s*i-o*a,0,u*i*o-s*a,u*o*o+c,u*s*o+i*a,0,u*i*s+o*a,u*o*s-i*a,u*s*s+c,0,0,0,0,1],h))},makeMatrix4RotateX:(t,n=[0,0,0])=>vn(t,n,1,2,!0),makeMatrix4RotateY:(t,n=[0,0,0])=>vn(t,n,0,2,!1),makeMatrix4RotateZ:(t,n=[0,0,0])=>vn(t,n,0,1,!0),makeMatrix4Scale:yn,makeMatrix4Translate:dn,makeMatrix4UniformScale:(t=1,n=[0,0,0])=>yn([t,t,t],n),makeOrthographicMatrix4:(t,n,e,r,i,o)=>[2/(n-r),0,0,0,0,2/(t-e),0,0,0,0,2/(i-o),0,(r+n)/(r-n),(e+t)/(e-t),(i+o)/(i-o),1],makePerspectiveMatrix4:(t,n,e,r)=>{const i=Math.tan(.5*Math.PI-.5*t),o=1/(e-r);return[i/n,0,0,0,0,i,0,0,0,0,(e+r)*o,-1,0,0,e*r*o*2,0]},multiplyMatrices4:fn,multiplyMatrix4Line3:(t,n,e)=>({vector:[t[0]*n[0]+t[4]*n[1]+t[8]*n[2],t[1]*n[0]+t[5]*n[1]+t[9]*n[2],t[2]*n[0]+t[6]*n[1]+t[10]*n[2]],origin:[t[0]*e[0]+t[4]*e[1]+t[8]*e[2]+t[12],t[1]*e[0]+t[5]*e[1]+t[9]*e[2]+t[13],t[2]*e[0]+t[6]*e[1]+t[10]*e[2]+t[14]]}),multiplyMatrix4Vector3:(t,n)=>[t[0]*n[0]+t[4]*n[1]+t[8]*n[2]+t[12],t[1]*n[0]+t[5]*n[1]+t[9]*n[2]+t[13],t[2]*n[0]+t[6]*n[1]+t[10]*n[2]+t[14]]}),xn={...it,...lt,...wt,...Mn,...Object.freeze({__proto__:null,matrix4FromQuaternion:t=>fn([t[3],t[2],-t[1],t[0],-t[2],t[3],t[0],t[1],t[1],-t[0],t[3],t[2],-t[0],-t[1],-t[2],t[3]],[t[3],t[2],-t[1],-t[0],-t[2],t[3],t[0],-t[1],t[1],-t[0],t[3],-t[2],t[0],t[1],t[2],t[3]]),quaternionFromTwoVectors:(t,n)=>{const e=D(t,n),r=[e[0],e[1],e[2],E(t,n)];return r[3]+=b(r),j(r)}})},bn=(t,n)=>{for(;t<0;)t+=r;for(;n<0;)n+=r;for(;t>r;)t-=r;for(;n>r;)n-=r;const e=t-n;return e>=0?e:r-(n-t)},_n=(t,n)=>{for(;t<0;)t+=r;for(;n<0;)n+=r;for(;t>r;)t-=r;for(;n>r;)n-=r;const e=n-t;return e>=0?e:r-(t-n)},Pn=(t,n)=>{const e=n[0]*t[0]+n[1]*t[1],i=n[0]*t[1]-n[1]*t[0];let o=Math.atan2(i,e);return o<0&&(o+=r),o},On=(t,n)=>{const e=t[0]*n[0]+t[1]*n[1],i=t[0]*n[1]-t[1]*n[0];let o=Math.atan2(i,e);return o<0&&(o+=r),o},jn=(t,n)=>Ut(Dt(t)-Pn(t,n)/2),kn=(t,n)=>Ut(Dt(t)+On(t,n)/2),An=(t,n,e)=>{const r=bn(t,n)/e;return Array.from(Array(e-1)).map(((n,e)=>t+r*(e+1)))},wn=(t,n,e)=>{const r=_n(t,n)/e;return Array.from(Array(e-1)).map(((n,e)=>t+r*(e+1)))},Sn=(t,n,e)=>{const r=Math.atan2(t[1],t[0]),i=Math.atan2(n[1],n[0]);return wn(r,i,e).map(Ut)},$n=t=>{const n=t.map(((t,n)=>n)).sort(((n,e)=>t[n]-t[e]));return n.slice(n.indexOf(0),n.length).concat(n.slice(0,n.indexOf(0)))},zn=t=>$n(t).map((n=>t[n])).map(((t,n,e)=>[t,e[(n+1)%e.length]])).map((t=>_n(t[0],t[1]))),Nn=(n,e,r,i=t)=>{const s=k(L(e,n)),c=k(L(r,n)),a=Z(s,c);return o(a,0,i)?o(X(n,e)+X(e,r),X(n,r))?0:void 0:Math.sign(a)},In=Object.freeze({__proto__:null,clockwiseAngle2:Pn,clockwiseAngleRadians:bn,clockwiseBisect2:jn,clockwiseSubsect2:(t,n,e)=>{const r=Math.atan2(t[1],t[0]),i=Math.atan2(n[1],n[0]);return An(r,i,e).map(Ut)},clockwiseSubsectRadians:An,counterClockwiseAngle2:On,counterClockwiseAngleRadians:_n,counterClockwiseBisect2:kn,counterClockwiseOrder2:t=>$n(t.map(Dt)),counterClockwiseOrderRadians:$n,counterClockwiseSectors2:t=>zn(t.map(Dt)),counterClockwiseSectorsRadians:zn,counterClockwiseSubsect2:Sn,counterClockwiseSubsectRadians:wn,isCounterClockwiseBetween:(t,n,e)=>{for(;e<n;)e+=r;for(;t>n;)t-=r;for(;t<n;)t+=r;return t<e},threePointTurnDirection:Nn}),Cn=(n=[],e=!1,r=t)=>{if(n.length<2)return[];const i=cn(n,r).map((t=>1===t.length?t:(t=>t.concat(t.slice(0,-1).reverse()))(t))).flat();i.push(i[0]);const o=[i[0]];let s=1;const c={"-1":()=>o.pop(),1:t=>{o.push(t),s+=1},undefined:()=>{s+=1}};for(c[0]=e?c[1]:c[-1];s<i.length;){if(o.length<2){o.push(i[s]),s+=1;continue}const t=o[o.length-2],e=o[o.length-1],a=i[s];c[Nn(...[t,e,a].map((t=>n[t])),r)](a)}return o.pop(),o},Ln=Object.freeze({__proto__:null,convexHull:Cn}),Rn=(n,e,r,i=t)=>{const o=E(n.vector,e.vector),s=Z(n.vector,e.vector),c=Z(L(e.origin,n.origin),e.vector)/s,a=[n.vector,e.vector].map((t=>j(t))),u=(s>-i?[[n.vector,e.vector],[Y(e.vector),n.vector]]:[[e.vector,n.vector],[Y(n.vector),e.vector]]).map((t=>Sn(t[0],t[1],r))),h=Math.abs(Z(...a))<i,l=h?void 0:N(n.origin,S(n.vector,c)),p=Array.from(Array(r-1)),f=h?p.map(((t,i)=>G(n.origin,e.origin,(i+1)/r))):p.map((()=>l)),m=u.map((t=>t.map(((t,n)=>({vector:t,origin:[...f[n]]})))));return h&&(m[o>-i?1:0]=[]),m},En=(n,e,r=t)=>{const i=Rn(n,e,2,r).map((t=>t[0]));return i.forEach(((t,n)=>{void 0===t&&delete i[n]})),i},qn=Object.freeze({__proto__:null,bisectLines2:En,collinearBetween:(n,e,r,i=!1,s=t)=>{if([n,r].map((t=>c(e,t,s))).reduce(((t,n)=>t||n),!1))return i;const a=[[n,e],[e,r]].map((t=>C(t[1],t[0]))).map((t=>j(t)));return o(1,E(...a),t)},lerpLines:(t,n,e)=>({vector:G(t.vector,n.vector,e),origin:G(t.origin,n.origin,e)}),pleat:Rn}),Bn=({vector:n,origin:e},r,i=d,o=t)=>{e=tt(n.length,e),r=tt(n.length,r);const s=O(n),c=C(r,e),a=i(E(n,c)/s,o);return z(e,w(n,a))},Tn=(t,n)=>t.map(((t,n,e)=>C(e[(n+1)%e.length],t))).map(((n,e)=>({vector:n,origin:t[e]}))).map((t=>Bn(t,n,y))).map(((t,e)=>({point:t,edge:e,distance:U(t,n)}))).sort(((t,n)=>t.distance-n.distance)).shift(),Vn=({radius:t,origin:n},e)=>z(n,w(j(C(e,n)),t)),Fn=Object.freeze({__proto__:null,nearestPoint:(t,n)=>{const e=Kt(t,n,U);return void 0===e?void 0:t[e]},nearestPoint2:(t,n)=>{const e=Kt(t,n,X);return void 0===e?void 0:t[e]},nearestPointOnCircle:Vn,nearestPointOnLine:Bn,nearestPointOnPolygon:Tn}),Gn=t=>Array.from(Array(Math.floor(t))).map(((n,e)=>r*(e/t))),Zn=(t,n)=>t.map((t=>[n*Math.cos(t),n*Math.sin(t)])),Dn=(t=3,n=1)=>Zn(Gn(t),n),Un=(t=3,n=1)=>{const e=Math.PI/t,r=Gn(t).map((t=>t+e));return Zn(r,n)},Xn=(n,e,r)=>{const i=e[0]-n[0],o=e[1]-n[1],s=r[0]-n[0],c=r[1]-n[1],a=i*(n[0]+e[0])+o*(n[1]+e[1]),u=s*(n[0]+r[0])+c*(n[1]+r[1]),h=2*(i*(r[1]-e[1])-o*(r[0]-e[0]));if(Math.abs(h)<t){const t=Math.min(n[0],e[0],r[0]),i=Math.min(n[1],e[1],r[1]),o=.5*(Math.max(n[0],e[0],r[0])-t),s=.5*(Math.max(n[1],e[1],r[1])-i);return{origin:[t+o,i+s],radius:Math.sqrt(o*o+s*s)}}const l=[(c*a-o*u)/h,(i*u-s*a)/h],p=l[0]-n[0],f=l[1]-n[1];return{origin:l,radius:Math.sqrt(p*p+f*f)}},Yn=t=>.5*t.map(((t,n,e)=>[t,e[(n+1)%e.length]])).map((t=>Z(...t))).reduce(((t,n)=>t+n),0),Hn=t=>{const n=1/(6*Yn(t));return t.map(((t,n,e)=>[t,e[(n+1)%e.length]])).map((t=>S(N(...t),Z(...t)))).reduce(((t,n)=>N(t,n)),[0,0]).map((t=>t*n))},Qn=(t,n=0)=>{if(!t||!t.length)return;const e=Array(t[0].length).fill(1/0),r=Array(t[0].length).fill(-1/0);t.forEach((t=>t.forEach(((t,i)=>{t<e[i]&&(e[i]=t-n),t>r[i]&&(r[i]=t+n)}))));const i=r.map(((t,n)=>t-e[n]));return{min:e,max:r,span:i}},Wn=Object.freeze({__proto__:null,boundingBox:Qn,centroid:Hn,circumcircle:Xn,makePolygonCircumradius:Dn,makePolygonCircumradiusSide:Un,makePolygonInradius:(t=3,n=1)=>Dn(t,n/Math.cos(Math.PI/t)),makePolygonInradiusSide:(t=3,n=1)=>Un(t,n/Math.cos(Math.PI/t)),makePolygonNonCollinear:(n,e=t)=>{const r=n.map(((t,n,e)=>[t,e[(n+1)%e.length]])).map((t=>C(t[1],t[0]))).map(((t,n,e)=>[t,e[(n+e.length-1)%e.length]])).map((t=>!K(t[1],t[0],e)));return n.filter(((t,n)=>r[n]))},makePolygonSideLength:(t=3,n=1)=>Dn(t,n/2/Math.sin(Math.PI/t)),makePolygonSideLengthSide:(t=3,n=1)=>Un(t,n/2/Math.sin(Math.PI/t)),signedArea:Yn}),Jn=({vector:n,origin:e},r,i=h,o=t)=>{const s=L(r,e),c=O(n),a=Math.sqrt(c);if(a<o)return!1;const u=Z(s,n.map((t=>t/a))),l=q(s,n)/c;return Math.abs(u)<o&&i(l,o/a)},Kn=(n,e,r=h,i=h,o=t)=>{const s=Z(n.vector,e.vector),c=-s,a=L(e.origin,n.origin),u=[-a[0],-a[1]];if(Math.abs(s)<o){if(Math.abs(Z(a,n.vector))>o)return!1;const t=u,s=N(t,n.vector),c=V(t,s),h=a,l=N(h,e.vector),p=V(h,l),f=q(n.vector,n.vector),m=q(e.vector,e.vector),g=q(t,e.vector)/m,d=q(s,e.vector)/m,v=q(c,e.vector)/m,y=q(h,n.vector)/f,M=q(l,n.vector)/f,x=q(p,n.vector)/f;return r(y,o)||r(M,o)||i(g,o)||i(d,o)||r(x,o)||i(v,o)}const l=Z(a,e.vector)/s,p=Z(u,n.vector)/c;return r(l,o/_(n.vector))&&i(p,o/_(e.vector))},te=({radius:n,origin:e},r,i=u,o=t)=>i(n-X(e,r),o),ne=(n,e,r=u,i=t)=>n.map(((t,n,e)=>[t,e[(n+1)%e.length]])).map((t=>Z(k(L(t[1],t[0])),L(e,t[0])))).map((t=>r(t,i))).map(((t,n,e)=>t===e[0])).reduce(((t,n)=>t&&n),!0),ee=(n,e,r=t)=>{for(let t=0;t<2;t+=1){const i=0===t?n:e,o=0===t?e:n;for(let t=0;t<i.length;t+=1){const n=i[t],e=H(L(i[(t+1)%i.length],i[t])),s=o.map((t=>L(t,n))).map((t=>q(e,t))),c=i[(t+2)%i.length],a=q(e,L(c,n))>0;if(s.map((t=>a?t<r:t>-r)).reduce(((t,n)=>t&&n),!0))return!1}}return!0},re=Object.freeze({__proto__:null,overlapBoundingBoxes:(n,e,r=t)=>{const i=Math.min(n.min.length,e.min.length);for(let t=0;t<i;t+=1)if(n.min[t]>e.max[t]+r||n.max[t]<e.min[t]-r)return!1;return!0},overlapCirclePoint:te,overlapConvexPolygonPoint:ne,overlapConvexPolygons:ee,overlapLineLine:Kn,overlapLinePoint:Jn}),ie=(n,e,r=h,i=h,o=t)=>{const s=Z(k(n.vector),k(e.vector));if(Math.abs(s)<o)return;const c=Z(n.vector,e.vector),a=-c,u=[e.origin[0]-n.origin[0],e.origin[1]-n.origin[1]],l=[-u[0],-u[1]],p=Z(u,e.vector)/c,f=Z(l,n.vector)/a;return r(p,o/_(n.vector))&&i(f,o/_(e.vector))?N(n.origin,S(n.vector,p)):void 0},oe=(t,n,e)=>{const r=n[0]-t[0],i=n[1]-t[1],o=r*Math.cos(e)+i*Math.sin(e),s=i*Math.cos(e)-r*Math.sin(e);return[t[0]+o,t[1]+s]},se=t=>{for(let n=1;n<t.length;n+=1)if(!c(t[0],t[n]))return[t[0],t[n]]},ce=(n,{vector:e,origin:r},i=m,o=h,s=t)=>{const c=n.map(((t,n,e)=>[t,e[(n+1)%e.length]])).map((t=>ie({vector:L(t[1],t[0]),origin:t[0]},{vector:e,origin:r},i,o,s))).filter((t=>void 0!==t));switch(c.length){case 0:return;case 1:return[c];default:return se(c)||[c[0]]}},ae=Object.freeze({__proto__:null,intersectCircleCircle:(n,e,r=a,i=a,o=t)=>{const s=n.radius<e.radius?n.radius:e.radius,c=n.radius<e.radius?e.radius:n.radius,u=n.radius<e.radius?n.origin:e.origin,h=n.radius<e.radius?e.origin:n.origin,l=[u[0]-h[0],u[1]-h[1]],p=Math.sqrt(l[0]**2+l[1]**2);if(p<o)return;const f=l.map(((t,n)=>t/p*c+h[n]));if(Math.abs(c+s-p)<o||Math.abs(c-(s+p))<o)return[f];if(p+s<c||c+s<p)return;const m=(g=(s*s-p*p-c*c)/(-2*p*c))>=1?0:g<=-1?Math.PI:Math.acos(g);var g;return[oe(h,f,+m),oe(h,f,-m)]},intersectCircleLine:(n,e,r=a,i=h,o=t)=>{const s=e.vector[0]**2+e.vector[1]**2,c=Math.sqrt(s),u=0===c?e.vector:e.vector.map((t=>t/c)),l=H(u),p=L(e.origin,n.origin),f=Z(p,u);if(Math.abs(f)>n.radius+o)return;const m=Math.sqrt(n.radius**2-f**2),g=(t,e)=>n.origin[e]-l[e]*f+u[e]*t,d=Math.abs(n.radius-Math.abs(f))<o?[m].map((t=>[t,t].map(g))):[-m,m].map((t=>[t,t].map(g))),v=d.map((t=>t.map(((t,n)=>t-e.origin[n])))).map((t=>t[0]*e.vector[0]+e.vector[1]*t[1])).map((t=>t/s));return d.filter(((t,n)=>i(v[n],o)))},intersectConvexPolygonLine:(n,{vector:e,origin:r},i=m,o=l,s=t)=>{const c=ce(n,{vector:e,origin:r},i,o,s);let a;switch(o){case f:a=p;break;case g:a=m;break;default:return c}const h=ce(n,{vector:e,origin:r},m,a,s);if(void 0===h)return;const d=se(h);if(void 0===d)switch(o){case f:return ne(n,r,u,.001)?h:void 0;case g:return ne(n,N(r,e),u,.001)||ne(n,r,u,.001)?h:void 0;default:return}return ne(n,V(...d),u,.001)?d:c},intersectLineLine:ie}),ue=(t,n,e)=>{const r=t.map(((t,n)=>({vector:e[n],origin:t}))).map(((t,n,e)=>ie(t,e[(n+1)%e.length],f,f))),i=n.map(((t,n)=>Bn(t,r[n],(t=>t))));if(3===t.length)return t.map((t=>({type:"skeleton",points:[t,r[0]]}))).concat([{type:"perpendicular",points:[i[0],r[0]]}]);const o=r.map(((t,n)=>U(t,i[n])));let s=0;o.forEach(((t,n)=>{t<o[s]&&(s=n)}));const c=[{type:"skeleton",points:[t[s],r[s]]},{type:"skeleton",points:[t[(s+1)%t.length],r[s]]},{type:"perpendicular",points:[i[s],r[s]]}],a=jn(Y(n[(s+n.length-1)%n.length].vector),n[(s+1)%n.length].vector),u=s===t.length-1;return t.splice(s,2,r[s]),n.splice(s,1),e.splice(s,2,a),u&&(t.splice(0,1),e.splice(0,1),n.push(n.shift())),c.concat(ue(t,n,e))},he=t=>{const n=t.map(((t,n,e)=>[t,e[(n+1)%e.length]])).map((t=>({vector:C(t[1],t[0]),origin:t[0]}))),e=t.map(((t,n,e)=>[(n-1+e.length)%e.length,n,(n+1)%e.length].map((t=>e[t])))).map((t=>[C(t[0],t[1]),C(t[2],t[1])])).map((t=>jn(...t)));return ue([...t],n,e)},le={...Ln,...qn,...Fn,...rn,...Wn,...In,straightSkeleton:he},pe=Object.freeze({__proto__:null,enclosingBoundingBoxes:(n,e,r=t)=>{const i=Math.min(n.min.length,e.min.length);for(let t=0;t<i;t+=1)if(e.min[t]<n.min[t]-r||e.max[t]>n.max[t]+r)return!1;return!0},pointInBoundingBox:(n,e,r=t)=>{for(let t=0;t<n.length;t+=1)if(n[t]<e.min[t]-r||n[t]>e.max[t]+r)return!1;return!0}}),fe=(t,n,e)=>N(n,S(t,e)),me=(n,e,r,i,o)=>n.map(((t,n,e)=>[L(e[(n+1)%e.length],t),t])).map((n=>((n,e,r,i,o=m,s=t)=>{const c=Z(k(n),k(r));if(Math.abs(c)<s)return;const a=Z(n,r),u=-a,h=L(i,e),l=Y(h),p=Z(h,r)/a;return o(Z(l,n)/u,s/_(r))?p:void 0})(e,r,n[0],n[1],i,o))).filter((t=>void 0!==t)).sort(((t,n)=>t-n)),ge=(n,{vector:e,origin:r},i=a,o=h,s=t)=>{const c=me(n,e,r,m,s);if(c.length<2)return;const u=((t,n,e)=>{let r=0,i=t.length-1;for(;r<i&&!n(t[r+1]-t[r],e);)r+=1;for(;i>r&&!n(t[i]-t[i-1],e);)i-=1;if(!(r>=i))return[t[r],t[i]]})(c,i,2*s/_(e));if(void 0===u)return;const l=u.map((t=>o(t)?t:t<.5?0:1));if(Math.abs(l[0]-l[1])<2*s/_(e))return;const p=fe(e,r,(l[0]+l[1])/2);return ne(n,p,i,s)?l.map((t=>fe(e,r,t))):void 0},de=Object.freeze({__proto__:null,clipLineConvexPolygon:ge,clipLineInBoundingBox:({vector:t,origin:n},{min:e,max:r,span:i})=>ge(),clipPolygonPolygon:(n,e,r=t)=>{const i=(t,n,e)=>(e[0]-n[0])*(t[1]-n[1])>(e[1]-n[1])*(t[0]-n[0])+r,o=(t,n,e,r)=>{const i=L(t,n),o=L(r,e),s=Z(t,n),c=Z(r,e),a=1/Z(i,o);return S(L(S(o,s),S(i,c)),a)};let s=n,c=e[e.length-1];for(let t=0;t<e.length;t+=1){const n=e[t],r=s;s=[];let a=r[r.length-1];for(let t=0;t<r.length;t+=1){const e=r[t];i(e,c,n)?(i(a,c,n)||s.push(o(c,n,e,a)),s.push(e)):i(a,c,n)&&s.push(o(c,n,e,a)),a=e}c=n}return 0===s.length?void 0:s}}),ve=(t,n)=>{const e=t.map(((t,e)=>({point:Jn(n,t,h)?t:null,at_index:e}))).filter((t=>null!=t.point)),r=t.map(((t,n,e)=>({vector:C(t,e[(n+1)%e.length]),origin:e[(n+1)%e.length]}))).map(((t,e)=>({point:ie(n,t,l,g),at_index:e}))).filter((t=>null!=t.point));if(2===r.length){const n=r.slice().sort(((t,n)=>t.at_index-n.at_index)),e=t.slice(n[1].at_index+1).concat(t.slice(0,n[0].at_index+1));e.push(n[0].point),e.push(n[1].point);const i=t.slice(n[0].at_index+1,n[1].at_index+1);return i.push(n[1].point),i.push(n[0].point),[e,i]}if(1===r.length&&1===e.length){e[0].type="v",r[0].type="e";const n=e.concat(r).sort(((t,n)=>t.at_index-n.at_index)),i=t.slice(n[1].at_index+1).concat(t.slice(0,n[0].at_index+1));"e"===n[0].type&&i.push(n[0].point),i.push(n[1].point);const o=t.slice(n[0].at_index+1,n[1].at_index+1);return"e"===n[1].type&&o.push(n[1].point),o.push(n[0].point),[i,o]}if(2===e.length){const n=e.slice().sort(((t,n)=>t.at_index-n.at_index));return[t.slice(n[1].at_index).concat(t.slice(0,n[0].at_index+1)),t.slice(n[0].at_index,n[1].at_index+1)]}return[t.slice()]},ye=Object.freeze({__proto__:null,splitConvexPolygon:ve}),Me={polygon:m,circle:a,line:h,ray:p,segment:m},xe=(n,e,r=t)=>{const i=t=>"polygon"===t?"ConvexPolygon":(t=>t.charAt(0).toUpperCase()+t.slice(1))(t),o=[n,e].map(hn),s=[o,o.slice().reverse()].map((t=>t.map(i).join(""))).map((t=>ae[`intersect${t}`])),c=[n.domain,e.domain].map(((t,n)=>t||Me[o[n]])),a=[[n,e,...c],[e,n,...c.slice().reverse()]],u=s.map(((t,n)=>({fn:t,params:a[n]}))).filter((t=>t.fn)).shift();return u?u.fn(...u.params,r):void 0},be={...pe,...re,...ae,...de,...ye,intersect:xe},_e=Object.create(null),Pe={polygon:{polygon:(t,n,e,r,i)=>ee(t,n,i),vector:(t,n,e,r,i)=>ne(t,n,e,i)},circle:{vector:(t,n,e,r,i)=>te(t,n,u,i)},line:{line:(t,n,e,r,i)=>Kn(t,n,e,r,i),ray:(t,n,e,r,i)=>Kn(t,n,e,r,i),segment:(t,n,e,r,i)=>Kn(t,n,e,r,i),vector:(t,n,e,r,i)=>Jn(t,n,e,i)},ray:{line:(t,n,e,r,i)=>Kn(n,t,r,e,i),ray:(t,n,e,r,i)=>Kn(t,n,e,r,i),segment:(t,n,e,r,i)=>Kn(t,n,e,r,i),vector:(t,n,e,r,i)=>Jn(t,n,e,i)},segment:{line:(t,n,e,r,i)=>Kn(n,t,r,e,i),ray:(t,n,e,r,i)=>Kn(n,t,r,e,i),segment:(t,n,e,r,i)=>Kn(t,n,e,r,i),vector:(t,n,e,r,i)=>Jn(t,n,e,i)},vector:{polygon:(t,n,e,r,i)=>ne(n,t,r,i),circle:(t,n,e,r,i)=>te(n,t,u,i),line:(t,n,e,r,i)=>Jn(n,t,r,i),ray:(t,n,e,r,i)=>Jn(n,t,r,i),segment:(t,n,e,r,i)=>Jn(n,t,r,i),vector:(t,n,e,r,i)=>c(t,n,i)}},Oe={polygon:"polygon",rect:"polygon",circle:"circle",line:"line",ray:"ray",segment:"segment",vector:"vector"},je={polygon:u,rect:u,circle:u,line:l,ray:f,segment:g,vector:l},ke=function(t,n,e){const r=hn(t),i=hn(n),o=Oe[r],s=Oe[i],c=t.domain||je[r],a=n.domain||je[i];return Pe[o][s](t,n,c,a,e)},Ae={preserve:{magnitude:function(){return b(this)},isEquivalent:function(){return c(this,It(arguments))},isParallel:function(){return K(...nt(this,It(arguments)))},isCollinear:function(t){return ke(this,t)},dot:function(){return E(...nt(this,It(arguments)))},distanceTo:function(){return U(...nt(this,It(arguments)))},overlap:function(t){return ke(this,t)}},vector:{copy:function(){return[...this]},normalize:function(){return j(this)},scale:function(){return w(this,arguments[0])},flip:function(){return Y(this)},rotate90:function(){return H(this)},rotate270:function(){return Q(this)},cross:function(){return D(tt(3,this),tt(3,It(arguments)))},transform:function(){return gt(Bt(arguments),tt(3,this))},add:function(){return z(this,tt(this.length,It(arguments)))},subtract:function(){return C(this,tt(this.length,It(arguments)))},rotateZ:function(t,n){return gt(Bt(ut(t,n)),tt(3,this))},lerp:function(t,n){return G(this,tt(this.length,It(t)),n)},midpoint:function(){return T(...nt(this,It(arguments)))},bisect:function(){return kn(this,It(arguments))}}},we={};Object.keys(Ae.preserve).forEach((t=>{we[t]=Ae.preserve[t]})),Object.keys(Ae.vector).forEach((t=>{we[t]=function(){return _e.vector(...Ae.vector[t].apply(this,arguments))}}));const Se={fromAngle:function(t){return _e.vector(Math.cos(t),Math.sin(t))},fromAngleDegrees:function(t){return _e.vector.fromAngle(t*e)}},$e={vector:{P:Array.prototype,A:function(){this.push(...It(arguments))},G:{x:function(){return this[0]},y:function(){return this[1]},z:function(){return this[2]}},M:we,S:Se}},ze={fromPoints:function(){const t=Ct(arguments);return this.constructor({vector:C(t[1],t[0]),origin:t[0]})},fromAngle:function(){const t=arguments[0]||0;return this.constructor({vector:[Math.cos(t),Math.sin(t)],origin:[0,0]})},perpendicularBisector:function(){const t=Ct(arguments);return this.constructor({vector:H(C(t[1],t[0])),origin:F(t[0],t[1])})}},Ne={isParallel:function(){const t=nt(this.vector,Et(arguments).vector);return K(...t)},isCollinear:function(){const t=Et(arguments);return Jn({vector:this.vector,origin:this.origin},t.origin)&&K(...nt(this.vector,t.vector))},isDegenerate:function(n=t){return W(this.vector,n)},reflectionMatrix:function(){return _e.matrix(At(this.vector,this.origin))},nearestPoint:function(){const t=It(arguments);return _e.vector(Bn(this,t,this.clip_function))},transform:function(){const t=this.dimension,n=dt(Bt(arguments),tt(3,this.vector),tt(3,this.origin));return this.constructor(tt(t,n.vector),tt(t,n.origin))},translate:function(){const t=z(...nt(this.origin,It(arguments)));return this.constructor(this.vector,t)},intersect:function(){return xe(this,...arguments)},overlap:function(){return ke(this,...arguments)},bisect:function(t,n){const e=Et(t);return En(this.vector,this.origin,e.vector,e.origin).map((t=>this.constructor(t)))}},Ie={line:{P:Object.prototype,A:function(){const t=Et(...arguments);this.vector=_e.vector(t.vector),this.origin=_e.vector(tt(this.vector.length,t.origin));const n=Xt({vector:this.vector,origin:this.origin});this.normal=n.normal,this.distance=n.distance,Object.defineProperty(this,"domain",{writable:!0,value:h})},G:{dimension:function(){return[this.vector,this.origin].map((t=>t.length)).reduce(((t,n)=>Math.max(t,n)),0)}},M:Object.assign({},Ne,{inclusive:function(){return this.domain=h,this},exclusive:function(){return this.domain=l,this},clip_function:t=>t,svgPath:function(t=2e4){const n=z(this.origin,w(this.vector,-t/2)),e=w(this.vector,t);return`M${n[0]} ${n[1]}l${e[0]} ${e[1]}`}}),S:Object.assign({fromNormalDistance:function(){return this.constructor(Yt(arguments[0]))}},ze)}},Ce={ray:{P:Object.prototype,A:function(){const t=Et(...arguments);this.vector=_e.vector(t.vector),this.origin=_e.vector(tt(this.vector.length,t.origin)),Object.defineProperty(this,"domain",{writable:!0,value:p})},G:{dimension:function(){return[this.vector,this.origin].map((t=>t.length)).reduce(((t,n)=>Math.max(t,n)),0)}},M:Object.assign({},Ne,{inclusive:function(){return this.domain=p,this},exclusive:function(){return this.domain=f,this},flip:function(){return _e.ray(Y(this.vector),this.origin)},scale:function(t){return _e.ray(this.vector.scale(t),this.origin)},normalize:function(){return _e.ray(this.vector.normalize(),this.origin)},clip_function:v,svgPath:function(t=1e4){const n=this.vector.scale(t);return`M${this.origin[0]} ${this.origin[1]}l${n[0]} ${n[1]}`}}),S:ze}},Le={segment:{P:Array.prototype,A:function(){const t=Lt(...arguments);this.push(...[t[0],t[1]].map((t=>_e.vector(t)))),this.vector=_e.vector(C(this[1],this[0])),this.origin=this[0],Object.defineProperty(this,"domain",{writable:!0,value:m})},G:{points:function(){return this},magnitude:function(){return b(this.vector)},dimension:function(){return[this.vector,this.origin].map((t=>t.length)).reduce(((t,n)=>Math.max(t,n)),0)}},M:Object.assign({},Ne,{inclusive:function(){return this.domain=m,this},exclusive:function(){return this.domain=g,this},clip_function:y,transform:function(...t){const n=this.points[0].length,e=Bt(t),r=this.points.map((t=>tt(3,t))).map((t=>gt(e,t))).map((t=>tt(n,t)));return _e.segment(r)},translate:function(){const t=It(arguments),n=this.points.map((n=>z(...nt(n,t))));return _e.segment(n)},midpoint:function(){return _e.vector(F(this.points[0],this.points[1]))},svgPath:function(){const t=this.points.map((t=>`${t[0]} ${t[1]}`));return["M","L"].map(((n,e)=>`${n}${t[e]}`)).join("")}}),S:{fromPoints:function(){return this.constructor(...arguments)}}}},Re=function(t,n,e,r,i,o){const s=Math.cos(i),c=Math.sin(i),a=Math.cos(o),u=Math.sin(o);return[t+s*e*a+-c*r*u,n+c*e*a+s*r*u]},Ee=function(t,n,e,r,i,o,s){let c=o;if(c<0&&!Number.isNaN(c))for(;c<0;)c+=2*Math.PI;const a=s>2*Math.PI?2*Math.PI:s,u=Re(t,n,e,r,i,c),h=Re(t,n,e,r,i,c+a/2),l=Re(t,n,e,r,i,c+a),p=a/2>Math.PI?1:0,f=a/2>0?1:0;return{x1:u[0],y1:u[1],x2:h[0],y2:h[1],x3:l[0],y3:l[1],fa:p,fs:f}},qe=t=>Wt(t,4),Be=(t,n,e,r,i,o,s)=>`A${qe(t)} ${qe(n)} ${qe(e)} ${qe(r)} ${qe(i)} ${qe(o)} ${qe(s)}`,Te={nearestPoint:function(){return _e.vector(Vn(this,It(arguments)))},intersect:function(t){return xe(this,t)},overlap:function(t){return ke(this,t)},svgPath:function(t=0,n=2*Math.PI){const e=Ee(this.origin[0],this.origin[1],this.radius,this.radius,0,t,n),r=Be(this.radius,this.radius,0,e.fa,e.fs,e.x2,e.y2),i=Be(this.radius,this.radius,0,e.fa,e.fs,e.x3,e.y3);return`M${e.x1} ${e.y1}${r}${i}`},points:function(t=128){return Array.from(Array(t)).map(((n,e)=>2*Math.PI/t*e)).map((t=>[this.origin[0]+this.radius*Math.cos(t),this.origin[1]+this.radius*Math.sin(t)]))},polygon:function(){return _e.polygon(this.points(arguments[0]))},segments:function(){const t=this.points(arguments[0]);return t.map(((n,e)=>{const r=(e+1)%t.length;return[n,t[r]]}))}},Ve={fromPoints:function(){if(3===arguments.length){const t=Xn(...arguments);return this.constructor(t.radius,t.origin)}return this.constructor(...arguments)},fromThreePoints:function(){const t=Xn(...arguments);return this.constructor(t.radius,t.origin)}},Fe={circle:{A:function(){const t=Gt(...arguments);this.radius=t.radius,this.origin=_e.vector(...t.origin)},G:{x:function(){return this.origin[0]},y:function(){return this.origin[1]},z:function(){return this.origin[2]}},M:Te,S:Ve}},Ge={ellipse:{A:function(){const t=zt(arguments).filter((t=>!Number.isNaN(t))),n=tt(5,t);this.rx=n[0],this.ry=n[1],this.origin=_e.vector(n[2],n[3]),this.spin=n[4],this.foci=function(t,n,e,r){const i=n>e,o=i?n**2-e**2:e**2-n**2,s=Math.sqrt(o),c=i?Math.cos(r):Math.sin(r),a=i?Math.sin(r):Math.cos(r);return[_e.vector(t[0]+s*c,t[1]+s*a),_e.vector(t[0]-s*c,t[1]-s*a)]}(this.origin,this.rx,this.ry,this.spin)},G:{x:function(){return this.origin[0]},y:function(){return this.origin[1]}},M:{svgPath:function(t=0,n=2*Math.PI){const e=Ee(this.origin[0],this.origin[1],this.rx,this.ry,this.spin,t,n),r=Be(this.rx,this.ry,this.spin/Math.PI*180,e.fa,e.fs,e.x2,e.y2),i=Be(this.rx,this.ry,this.spin/Math.PI*180,e.fa,e.fs,e.x3,e.y3);return`M${e.x1} ${e.y1}${r}${i}`},points:function(t=128){return Array.from(Array(t)).map(((n,e)=>2*Math.PI/t*e)).map((t=>Re(this.origin.x,this.origin.y,this.rx,this.ry,this.spin,t)))},polygon:function(){return _e.polygon(this.points(arguments[0]))},segments:function(){const t=this.points(arguments[0]);return t.map(((n,e)=>{const r=(e+1)%t.length;return[n,t[r]]}))}},S:{}}},Ze={area:function(){return Yn(this)},centroid:function(){return _e.vector(Hn(this))},boundingBox:function(){return Qn(this)},straightSkeleton:function(){return he(this)},scale:function(t,n=Hn(this)){const e=this.map((t=>[0,1].map(((e,r)=>t[r]-n[r])))).map((e=>e.map(((r,i)=>n[i]+e[i]*t))));return this.constructor.fromPoints(e)},rotate:function(t,n=Hn(this)){const e=this.map((e=>{const r=[e[0]-n[0],e[1]-n[1]],i=Math.sqrt(r[0]**2+r[1]**2),o=Math.atan2(r[1],r[0]);return[n[0]+Math.cos(o+t)*i,n[1]+Math.sin(o+t)*i]}));return _e.polygon(e)},translate:function(){const t=It(...arguments),n=this.map((n=>n.map(((n,e)=>n+t[e]))));return this.constructor.fromPoints(n)},transform:function(){const t=Bt(...arguments),n=this.map((n=>gt(t,tt(3,n))));return _e.polygon(n)},nearest:function(){const t=It(...arguments),n=Tn(this,t);return void 0===n?void 0:Object.assign(n,{edge:this.sides[n.i]})},split:function(){const t=Et(...arguments);return ve(this,t).map((t=>_e.polygon(t)))},overlap:function(){return ke(this,...arguments)},intersect:function(){return xe(this,...arguments)},clip:function(t,n){const e=t.domain?t.domain:h,r=ge(this,t,this.domain,e,n);return r?_e.segment(r):void 0},svgPath:function(){const t=Array(this.length).fill("L");return t[0]="M",`${this.map(((n,e)=>`${t[e]}${n[0]} ${n[1]}`)).join("")}z`}},De={rect:{P:Array.prototype,A:function(){const t=Vt(...arguments);this.width=t.width,this.height=t.height,this.origin=_e.vector(t.x,t.y),this.push(...(t=>[[t.x,t.y],[t.x+t.width,t.y],[t.x+t.width,t.y+t.height],[t.x,t.y+t.height]])(this)),Object.defineProperty(this,"domain",{writable:!0,value:a})},G:{x:function(){return this.origin[0]},y:function(){return this.origin[1]},center:function(){return _e.vector(this.origin[0]+this.width/2,this.origin[1]+this.height/2)}},M:Object.assign({},Ze,{inclusive:function(){return this.domain=a,this},exclusive:function(){return this.domain=u,this},area:function(){return this.width*this.height},segments:function(){return[[[(t=this).x,t.y],[t.x+t.width,t.y]],[[t.x+t.width,t.y],[t.x+t.width,t.y+t.height]],[[t.x+t.width,t.y+t.height],[t.x,t.y+t.height]],[[t.x,t.y+t.height],[t.x,t.y]]];var t},svgPath:function(){return`M${this.origin.join(" ")}h${this.width}v${this.height}h${-this.width}Z`}}),S:{fromPoints:function(){const t=Qn(Ct(arguments));return _e.rect(t.min[0],t.min[1],t.span[0],t.span[1])}}}},Ue={polygon:{P:Array.prototype,A:function(){this.push(...$t(arguments)),this.sides=this.map(((t,n,e)=>[t,e[(n+1)%e.length]])),this.vectors=this.sides.map((t=>C(t[1],t[0]))),Object.defineProperty(this,"domain",{writable:!0,value:a})},G:{isConvex:function(){},points:function(){return this}},M:Object.assign({},Ze,{inclusive:function(){return this.domain=a,this},exclusive:function(){return this.domain=u,this},segments:function(){return this.sides}}),S:{fromPoints:function(){return this.constructor(...arguments)},regularPolygon:function(){return this.constructor(Dn(...arguments))},convexHull:function(){return this.constructor(Cn(...arguments))}}}},Xe={polyline:{P:Array.prototype,A:function(){this.push(...$t(arguments))},G:{points:function(){return this}},M:{svgPath:function(){const t=Array(this.length).fill("L");return t[0]="M",`${this.map(((n,e)=>`${t[e]}${n[0]} ${n[1]}`)).join("")}`}},S:{fromPoints:function(){return this.constructor(...arguments)}}}},Ye=(t,n)=>{for(let e=0;e<12;e+=1)t[e]=n[e];return t},He={matrix:{P:Array.prototype,A:function(){Bt(arguments).forEach((t=>this.push(t)))},G:{},M:{copy:function(){return _e.matrix(...Array.from(this))},set:function(){return Ye(this,Bt(arguments))},isIdentity:function(){return mt(this)},multiply:function(t){return Ye(this,vt(this,t))},determinant:function(){return yt(this)},inverse:function(){return Ye(this,Mt(this))},translate:function(t,n,e){return Ye(this,vt(this,xt(t,n,e)))},rotateX:function(t){return Ye(this,vt(this,_t(t)))},rotateY:function(t){return Ye(this,vt(this,Pt(t)))},rotateZ:function(t){return Ye(this,vt(this,Ot(t)))},rotate:function(t,n,e){const r=jt(t,n,e);return Ye(this,vt(this,r))},scale:function(...t){return Ye(this,vt(this,kt(...t)))},reflectZ:function(t,n){const e=At(t,n);return Ye(this,vt(this,e))},transform:function(...t){return _e.vector(gt(this,tt(3,It(t))))},transformVector:function(t){return _e.vector(gt(this,tt(3,It(t))))},transformLine:function(...t){const n=Et(t);return _e.line(dt(this,n.vector,n.origin))}},S:{}}},Qe={...$e,...Ie,...Ce,...Le,...Fe,...Ge,...De,...Ue,...Xe,...He},We=function(t,n){const e=Object.create(Qe[t].proto);return Qe[t].A.apply(e,n),e};Object.assign(_e,{vector:function(){return We("vector",arguments)},line:function(){return We("line",arguments)},ray:function(){return We("ray",arguments)},segment:function(){return We("segment",arguments)},circle:function(){return We("circle",arguments)},ellipse:function(){return We("ellipse",arguments)},rect:function(){return We("rect",arguments)},polygon:function(){return We("polygon",arguments)},polyline:function(){return We("polyline",arguments)},matrix:function(){return We("matrix",arguments)}}),Object.keys(Qe).forEach((t=>{const n={};n.prototype=null!=Qe[t].P?Object.create(Qe[t].P):Object.create(Object.prototype),n.prototype.constructor=n,_e[t].prototype=n.prototype,_e[t].prototype.constructor=_e[t],Object.keys(Qe[t].G).forEach((e=>Object.defineProperty(n.prototype,e,{get:Qe[t].G[e]}))),Object.keys(Qe[t].M).forEach((e=>Object.defineProperty(n.prototype,e,{value:Qe[t].M[e]}))),Object.keys(Qe[t].S).forEach((n=>Object.defineProperty(_e[t],n,{value:Qe[t].S[n].bind(_e[t].prototype)}))),Qe[t].proto=n.prototype}));const Je=_e;return Object.assign(Je,{...ln,...xn,...le,...be}),Je}));